// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class Approval extends ethereum.Event {
  get params(): Approval__Params {
    return new Approval__Params(this);
  }
}

export class Approval__Params {
  _event: Approval;

  constructor(event: Approval) {
    this._event = event;
  }

  get owner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get spender(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class Deposit extends ethereum.Event {
  get params(): Deposit__Params {
    return new Deposit__Params(this);
  }
}

export class Deposit__Params {
  _event: Deposit;

  constructor(event: Deposit) {
    this._event = event;
  }

  get caller(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get owner(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get assets(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get shares(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class InstrumentDeny extends ethereum.Event {
  get params(): InstrumentDeny__Params {
    return new InstrumentDeny__Params(this);
  }
}

export class InstrumentDeny__Params {
  _event: InstrumentDeny;

  constructor(event: InstrumentDeny) {
    this._event = event;
  }

  get marketId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }
}

export class InstrumentDeposit extends ethereum.Event {
  get params(): InstrumentDeposit__Params {
    return new InstrumentDeposit__Params(this);
  }
}

export class InstrumentDeposit__Params {
  _event: InstrumentDeposit;

  constructor(event: InstrumentDeposit) {
    this._event = event;
  }

  get marketId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get instrument(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get isPool(): boolean {
    return this._event.parameters[3].value.toBoolean();
  }
}

export class InstrumentHarvest extends ethereum.Event {
  get params(): InstrumentHarvest__Params {
    return new InstrumentHarvest__Params(this);
  }
}

export class InstrumentHarvest__Params {
  _event: InstrumentHarvest;

  constructor(event: InstrumentHarvest) {
    this._event = event;
  }

  get instrument(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get totalInstrumentHoldings(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get instrument_balance(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get mag(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }

  get sign(): boolean {
    return this._event.parameters[4].value.toBoolean();
  }
}

export class InstrumentRemoved extends ethereum.Event {
  get params(): InstrumentRemoved__Params {
    return new InstrumentRemoved__Params(this);
  }
}

export class InstrumentRemoved__Params {
  _event: InstrumentRemoved;

  constructor(event: InstrumentRemoved) {
    this._event = event;
  }

  get marketId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get instrumentAddress(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class InstrumentTrusted extends ethereum.Event {
  get params(): InstrumentTrusted__Params {
    return new InstrumentTrusted__Params(this);
  }
}

export class InstrumentTrusted__Params {
  _event: InstrumentTrusted;

  constructor(event: InstrumentTrusted) {
    this._event = event;
  }

  get marketId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get instrument(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get principal(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get expectedYield(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }

  get maturityDate(): BigInt {
    return this._event.parameters[4].value.toBigInt();
  }
}

export class InstrumentWithdrawal extends ethereum.Event {
  get params(): InstrumentWithdrawal__Params {
    return new InstrumentWithdrawal__Params(this);
  }
}

export class InstrumentWithdrawal__Params {
  _event: InstrumentWithdrawal;

  constructor(event: InstrumentWithdrawal) {
    this._event = event;
  }

  get marketId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get instrument(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class Transfer extends ethereum.Event {
  get params(): Transfer__Params {
    return new Transfer__Params(this);
  }
}

export class Transfer__Params {
  _event: Transfer;

  constructor(event: Transfer) {
    this._event = event;
  }

  get from(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get to(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class Withdraw extends ethereum.Event {
  get params(): Withdraw__Params {
    return new Withdraw__Params(this);
  }
}

export class Withdraw__Params {
  _event: Withdraw;

  constructor(event: Withdraw) {
    this._event = event;
  }

  get caller(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get receiver(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get owner(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get assets(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }

  get shares(): BigInt {
    return this._event.parameters[4].value.toBigInt();
  }
}

export class Vault__fetchInstrumentDataResultValue0Struct extends ethereum.Tuple {
  get name(): Bytes {
    return this[0].toBytes();
  }

  get isPool(): boolean {
    return this[1].toBoolean();
  }

  get trusted(): boolean {
    return this[2].toBoolean();
  }

  get balance(): BigInt {
    return this[3].toBigInt();
  }

  get faceValue(): BigInt {
    return this[4].toBigInt();
  }

  get marketId(): BigInt {
    return this[5].toBigInt();
  }

  get principal(): BigInt {
    return this[6].toBigInt();
  }

  get expectedYield(): BigInt {
    return this[7].toBigInt();
  }

  get duration(): BigInt {
    return this[8].toBigInt();
  }

  get description(): string {
    return this[9].toString();
  }

  get instrument_address(): Address {
    return this[10].toAddress();
  }

  get instrument_type(): i32 {
    return this[11].toI32();
  }

  get maturityDate(): BigInt {
    return this[12].toBigInt();
  }

  get poolData(): Vault__fetchInstrumentDataResultValue0PoolDataStruct {
    return changetype<Vault__fetchInstrumentDataResultValue0PoolDataStruct>(
      this[13].toTuple()
    );
  }
}

export class Vault__fetchInstrumentDataResultValue0PoolDataStruct extends ethereum.Tuple {
  get saleAmount(): BigInt {
    return this[0].toBigInt();
  }

  get initPrice(): BigInt {
    return this[1].toBigInt();
  }

  get promisedReturn(): BigInt {
    return this[2].toBigInt();
  }

  get inceptionTime(): BigInt {
    return this[3].toBigInt();
  }

  get inceptionPrice(): BigInt {
    return this[4].toBigInt();
  }

  get leverageFactor(): BigInt {
    return this[5].toBigInt();
  }

  get managementFee(): BigInt {
    return this[6].toBigInt();
  }
}

export class Vault__fetchPoolTrancheDataResult {
  value0: BigInt;
  value1: BigInt;
  value2: BigInt;
  value3: BigInt;
  value4: BigInt;

  constructor(
    value0: BigInt,
    value1: BigInt,
    value2: BigInt,
    value3: BigInt,
    value4: BigInt
  ) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
    this.value3 = value3;
    this.value4 = value4;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    map.set("value2", ethereum.Value.fromUnsignedBigInt(this.value2));
    map.set("value3", ethereum.Value.fromUnsignedBigInt(this.value3));
    map.set("value4", ethereum.Value.fromUnsignedBigInt(this.value4));
    return map;
  }

  getValue0(): BigInt {
    return this.value0;
  }

  getValue1(): BigInt {
    return this.value1;
  }

  getValue2(): BigInt {
    return this.value2;
  }

  getValue3(): BigInt {
    return this.value3;
  }

  getValue4(): BigInt {
    return this.value4;
  }
}

export class Vault__getInstrumentDataResultValue0Struct extends ethereum.Tuple {
  get name(): Bytes {
    return this[0].toBytes();
  }

  get isPool(): boolean {
    return this[1].toBoolean();
  }

  get trusted(): boolean {
    return this[2].toBoolean();
  }

  get balance(): BigInt {
    return this[3].toBigInt();
  }

  get faceValue(): BigInt {
    return this[4].toBigInt();
  }

  get marketId(): BigInt {
    return this[5].toBigInt();
  }

  get principal(): BigInt {
    return this[6].toBigInt();
  }

  get expectedYield(): BigInt {
    return this[7].toBigInt();
  }

  get duration(): BigInt {
    return this[8].toBigInt();
  }

  get description(): string {
    return this[9].toString();
  }

  get instrument_address(): Address {
    return this[10].toAddress();
  }

  get instrument_type(): i32 {
    return this[11].toI32();
  }

  get maturityDate(): BigInt {
    return this[12].toBigInt();
  }

  get poolData(): Vault__getInstrumentDataResultValue0PoolDataStruct {
    return changetype<Vault__getInstrumentDataResultValue0PoolDataStruct>(
      this[13].toTuple()
    );
  }
}

export class Vault__getInstrumentDataResultValue0PoolDataStruct extends ethereum.Tuple {
  get saleAmount(): BigInt {
    return this[0].toBigInt();
  }

  get initPrice(): BigInt {
    return this[1].toBigInt();
  }

  get promisedReturn(): BigInt {
    return this[2].toBigInt();
  }

  get inceptionTime(): BigInt {
    return this[3].toBigInt();
  }

  get inceptionPrice(): BigInt {
    return this[4].toBigInt();
  }

  get leverageFactor(): BigInt {
    return this[5].toBigInt();
  }

  get managementFee(): BigInt {
    return this[6].toBigInt();
  }
}

export class Vault__get_vault_paramsResultValue0Struct extends ethereum.Tuple {
  get N(): BigInt {
    return this[0].toBigInt();
  }

  get sigma(): BigInt {
    return this[1].toBigInt();
  }

  get alpha(): BigInt {
    return this[2].toBigInt();
  }

  get omega(): BigInt {
    return this[3].toBigInt();
  }

  get delta(): BigInt {
    return this[4].toBigInt();
  }

  get r(): BigInt {
    return this[5].toBigInt();
  }

  get s(): BigInt {
    return this[6].toBigInt();
  }

  get steak(): BigInt {
    return this[7].toBigInt();
  }
}

export class Vault__instrument_dataResultPoolDataStruct extends ethereum.Tuple {
  get saleAmount(): BigInt {
    return this[0].toBigInt();
  }

  get initPrice(): BigInt {
    return this[1].toBigInt();
  }

  get promisedReturn(): BigInt {
    return this[2].toBigInt();
  }

  get inceptionTime(): BigInt {
    return this[3].toBigInt();
  }

  get inceptionPrice(): BigInt {
    return this[4].toBigInt();
  }

  get leverageFactor(): BigInt {
    return this[5].toBigInt();
  }

  get managementFee(): BigInt {
    return this[6].toBigInt();
  }
}

export class Vault__instrument_dataResult {
  value0: Bytes;
  value1: boolean;
  value2: boolean;
  value3: BigInt;
  value4: BigInt;
  value5: BigInt;
  value6: BigInt;
  value7: BigInt;
  value8: BigInt;
  value9: string;
  value10: Address;
  value11: i32;
  value12: BigInt;
  value13: Vault__instrument_dataResultPoolDataStruct;

  constructor(
    value0: Bytes,
    value1: boolean,
    value2: boolean,
    value3: BigInt,
    value4: BigInt,
    value5: BigInt,
    value6: BigInt,
    value7: BigInt,
    value8: BigInt,
    value9: string,
    value10: Address,
    value11: i32,
    value12: BigInt,
    value13: Vault__instrument_dataResultPoolDataStruct
  ) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
    this.value3 = value3;
    this.value4 = value4;
    this.value5 = value5;
    this.value6 = value6;
    this.value7 = value7;
    this.value8 = value8;
    this.value9 = value9;
    this.value10 = value10;
    this.value11 = value11;
    this.value12 = value12;
    this.value13 = value13;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromFixedBytes(this.value0));
    map.set("value1", ethereum.Value.fromBoolean(this.value1));
    map.set("value2", ethereum.Value.fromBoolean(this.value2));
    map.set("value3", ethereum.Value.fromUnsignedBigInt(this.value3));
    map.set("value4", ethereum.Value.fromUnsignedBigInt(this.value4));
    map.set("value5", ethereum.Value.fromUnsignedBigInt(this.value5));
    map.set("value6", ethereum.Value.fromUnsignedBigInt(this.value6));
    map.set("value7", ethereum.Value.fromUnsignedBigInt(this.value7));
    map.set("value8", ethereum.Value.fromUnsignedBigInt(this.value8));
    map.set("value9", ethereum.Value.fromString(this.value9));
    map.set("value10", ethereum.Value.fromAddress(this.value10));
    map.set(
      "value11",
      ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(this.value11))
    );
    map.set("value12", ethereum.Value.fromUnsignedBigInt(this.value12));
    map.set("value13", ethereum.Value.fromTuple(this.value13));
    return map;
  }

  getName(): Bytes {
    return this.value0;
  }

  getIsPool(): boolean {
    return this.value1;
  }

  getTrusted(): boolean {
    return this.value2;
  }

  getBalance(): BigInt {
    return this.value3;
  }

  getFaceValue(): BigInt {
    return this.value4;
  }

  getMarketId(): BigInt {
    return this.value5;
  }

  getPrincipal(): BigInt {
    return this.value6;
  }

  getExpectedYield(): BigInt {
    return this.value7;
  }

  getDuration(): BigInt {
    return this.value8;
  }

  getDescription(): string {
    return this.value9;
  }

  getInstrument_address(): Address {
    return this.value10;
  }

  getInstrument_type(): i32 {
    return this.value11;
  }

  getMaturityDate(): BigInt {
    return this.value12;
  }

  getPoolData(): Vault__instrument_dataResultPoolDataStruct {
    return this.value13;
  }
}

export class Vault__poolZCBValueResult {
  value0: BigInt;
  value1: BigInt;
  value2: BigInt;

  constructor(value0: BigInt, value1: BigInt, value2: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    map.set("value2", ethereum.Value.fromUnsignedBigInt(this.value2));
    return map;
  }

  getPsu(): BigInt {
    return this.value0;
  }

  getPju(): BigInt {
    return this.value1;
  }

  getLevFactor(): BigInt {
    return this.value2;
  }
}

export class Vault__resolveInstrumentResult {
  value0: boolean;
  value1: BigInt;
  value2: BigInt;
  value3: boolean;

  constructor(
    value0: boolean,
    value1: BigInt,
    value2: BigInt,
    value3: boolean
  ) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
    this.value3 = value3;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromBoolean(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    map.set("value2", ethereum.Value.fromUnsignedBigInt(this.value2));
    map.set("value3", ethereum.Value.fromBoolean(this.value3));
    return map;
  }

  getValue0(): boolean {
    return this.value0;
  }

  getValue1(): BigInt {
    return this.value1;
  }

  getValue2(): BigInt {
    return this.value2;
  }

  getValue3(): boolean {
    return this.value3;
  }
}

export class Vault__viewPrincipalAndYieldResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }

  getValue0(): BigInt {
    return this.value0;
  }

  getValue1(): BigInt {
    return this.value1;
  }
}

export class Vault extends ethereum.SmartContract {
  static bind(address: Address): Vault {
    return new Vault("Vault", address);
  }

  DOMAIN_SEPARATOR(): Bytes {
    let result = super.call(
      "DOMAIN_SEPARATOR",
      "DOMAIN_SEPARATOR():(bytes32)",
      []
    );

    return result[0].toBytes();
  }

  try_DOMAIN_SEPARATOR(): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "DOMAIN_SEPARATOR",
      "DOMAIN_SEPARATOR():(bytes32)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  Instruments(param0: BigInt): Address {
    let result = super.call("Instruments", "Instruments(uint256):(address)", [
      ethereum.Value.fromUnsignedBigInt(param0)
    ]);

    return result[0].toAddress();
  }

  try_Instruments(param0: BigInt): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "Instruments",
      "Instruments(uint256):(address)",
      [ethereum.Value.fromUnsignedBigInt(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  UNDERLYING(): Address {
    let result = super.call("UNDERLYING", "UNDERLYING():(address)", []);

    return result[0].toAddress();
  }

  try_UNDERLYING(): ethereum.CallResult<Address> {
    let result = super.tryCall("UNDERLYING", "UNDERLYING():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  allowance(param0: Address, param1: Address): BigInt {
    let result = super.call(
      "allowance",
      "allowance(address,address):(uint256)",
      [ethereum.Value.fromAddress(param0), ethereum.Value.fromAddress(param1)]
    );

    return result[0].toBigInt();
  }

  try_allowance(param0: Address, param1: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "allowance",
      "allowance(address,address):(uint256)",
      [ethereum.Value.fromAddress(param0), ethereum.Value.fromAddress(param1)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  approve(spender: Address, amount: BigInt): boolean {
    let result = super.call("approve", "approve(address,uint256):(bool)", [
      ethereum.Value.fromAddress(spender),
      ethereum.Value.fromUnsignedBigInt(amount)
    ]);

    return result[0].toBoolean();
  }

  try_approve(spender: Address, amount: BigInt): ethereum.CallResult<boolean> {
    let result = super.tryCall("approve", "approve(address,uint256):(bool)", [
      ethereum.Value.fromAddress(spender),
      ethereum.Value.fromUnsignedBigInt(amount)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  asset(): Address {
    let result = super.call("asset", "asset():(address)", []);

    return result[0].toAddress();
  }

  try_asset(): ethereum.CallResult<Address> {
    let result = super.tryCall("asset", "asset():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  asset_limit(): BigInt {
    let result = super.call("asset_limit", "asset_limit():(uint256)", []);

    return result[0].toBigInt();
  }

  try_asset_limit(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("asset_limit", "asset_limit():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  balanceInUnderlying(ad: Address): BigInt {
    let result = super.call(
      "balanceInUnderlying",
      "balanceInUnderlying(address):(uint256)",
      [ethereum.Value.fromAddress(ad)]
    );

    return result[0].toBigInt();
  }

  try_balanceInUnderlying(ad: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "balanceInUnderlying",
      "balanceInUnderlying(address):(uint256)",
      [ethereum.Value.fromAddress(ad)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  balanceOf(param0: Address): BigInt {
    let result = super.call("balanceOf", "balanceOf(address):(uint256)", [
      ethereum.Value.fromAddress(param0)
    ]);

    return result[0].toBigInt();
  }

  try_balanceOf(param0: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall("balanceOf", "balanceOf(address):(uint256)", [
      ethereum.Value.fromAddress(param0)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  convertToAssets(shares: BigInt): BigInt {
    let result = super.call(
      "convertToAssets",
      "convertToAssets(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(shares)]
    );

    return result[0].toBigInt();
  }

  try_convertToAssets(shares: BigInt): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "convertToAssets",
      "convertToAssets(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(shares)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  convertToShares(assets: BigInt): BigInt {
    let result = super.call(
      "convertToShares",
      "convertToShares(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(assets)]
    );

    return result[0].toBigInt();
  }

  try_convertToShares(assets: BigInt): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "convertToShares",
      "convertToShares(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(assets)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  decAssetsToShares(assets: BigInt): BigInt {
    let result = super.call(
      "decAssetsToShares",
      "decAssetsToShares(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(assets)]
    );

    return result[0].toBigInt();
  }

  try_decAssetsToShares(assets: BigInt): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "decAssetsToShares",
      "decAssetsToShares(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(assets)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  decSharesToAssets(shares: BigInt): BigInt {
    let result = super.call(
      "decSharesToAssets",
      "decSharesToAssets(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(shares)]
    );

    return result[0].toBigInt();
  }

  try_decSharesToAssets(shares: BigInt): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "decSharesToAssets",
      "decSharesToAssets(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(shares)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  decimal_mismatch(): boolean {
    let result = super.call(
      "decimal_mismatch",
      "decimal_mismatch():(bool)",
      []
    );

    return result[0].toBoolean();
  }

  try_decimal_mismatch(): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "decimal_mismatch",
      "decimal_mismatch():(bool)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  decimals(): i32 {
    let result = super.call("decimals", "decimals():(uint8)", []);

    return result[0].toI32();
  }

  try_decimals(): ethereum.CallResult<i32> {
    let result = super.tryCall("decimals", "decimals():(uint8)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  deposit(assets: BigInt, receiver: Address): BigInt {
    let result = super.call("deposit", "deposit(uint256,address):(uint256)", [
      ethereum.Value.fromUnsignedBigInt(assets),
      ethereum.Value.fromAddress(receiver)
    ]);

    return result[0].toBigInt();
  }

  try_deposit(assets: BigInt, receiver: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "deposit",
      "deposit(uint256,address):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(assets),
        ethereum.Value.fromAddress(receiver)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  enoughLiqudity(amounts: BigInt): boolean {
    let result = super.call(
      "enoughLiqudity",
      "enoughLiqudity(uint256):(bool)",
      [ethereum.Value.fromUnsignedBigInt(amounts)]
    );

    return result[0].toBoolean();
  }

  try_enoughLiqudity(amounts: BigInt): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "enoughLiqudity",
      "enoughLiqudity(uint256):(bool)",
      [ethereum.Value.fromUnsignedBigInt(amounts)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  fetchInstrument(marketId: BigInt): Address {
    let result = super.call(
      "fetchInstrument",
      "fetchInstrument(uint256):(address)",
      [ethereum.Value.fromUnsignedBigInt(marketId)]
    );

    return result[0].toAddress();
  }

  try_fetchInstrument(marketId: BigInt): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "fetchInstrument",
      "fetchInstrument(uint256):(address)",
      [ethereum.Value.fromUnsignedBigInt(marketId)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  fetchInstrumentData(
    marketId: BigInt
  ): Vault__fetchInstrumentDataResultValue0Struct {
    let result = super.call(
      "fetchInstrumentData",
      "fetchInstrumentData(uint256):((bytes32,bool,bool,uint256,uint256,uint256,uint256,uint256,uint256,string,address,uint8,uint256,(uint256,uint256,uint256,uint256,uint256,uint256,uint256)))",
      [ethereum.Value.fromUnsignedBigInt(marketId)]
    );

    return changetype<Vault__fetchInstrumentDataResultValue0Struct>(
      result[0].toTuple()
    );
  }

  try_fetchInstrumentData(
    marketId: BigInt
  ): ethereum.CallResult<Vault__fetchInstrumentDataResultValue0Struct> {
    let result = super.tryCall(
      "fetchInstrumentData",
      "fetchInstrumentData(uint256):((bytes32,bool,bool,uint256,uint256,uint256,uint256,uint256,uint256,string,address,uint8,uint256,(uint256,uint256,uint256,uint256,uint256,uint256,uint256)))",
      [ethereum.Value.fromUnsignedBigInt(marketId)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      changetype<Vault__fetchInstrumentDataResultValue0Struct>(
        value[0].toTuple()
      )
    );
  }

  fetchPoolTrancheData(marketId: BigInt): Vault__fetchPoolTrancheDataResult {
    let result = super.call(
      "fetchPoolTrancheData",
      "fetchPoolTrancheData(uint256):(uint256,uint256,uint256,uint256,uint256)",
      [ethereum.Value.fromUnsignedBigInt(marketId)]
    );

    return new Vault__fetchPoolTrancheDataResult(
      result[0].toBigInt(),
      result[1].toBigInt(),
      result[2].toBigInt(),
      result[3].toBigInt(),
      result[4].toBigInt()
    );
  }

  try_fetchPoolTrancheData(
    marketId: BigInt
  ): ethereum.CallResult<Vault__fetchPoolTrancheDataResult> {
    let result = super.tryCall(
      "fetchPoolTrancheData",
      "fetchPoolTrancheData(uint256):(uint256,uint256,uint256,uint256,uint256)",
      [ethereum.Value.fromUnsignedBigInt(marketId)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new Vault__fetchPoolTrancheDataResult(
        value[0].toBigInt(),
        value[1].toBigInt(),
        value[2].toBigInt(),
        value[3].toBigInt(),
        value[4].toBigInt()
      )
    );
  }

  getInstrumentData(
    _instrument: Address
  ): Vault__getInstrumentDataResultValue0Struct {
    let result = super.call(
      "getInstrumentData",
      "getInstrumentData(address):((bytes32,bool,bool,uint256,uint256,uint256,uint256,uint256,uint256,string,address,uint8,uint256,(uint256,uint256,uint256,uint256,uint256,uint256,uint256)))",
      [ethereum.Value.fromAddress(_instrument)]
    );

    return changetype<Vault__getInstrumentDataResultValue0Struct>(
      result[0].toTuple()
    );
  }

  try_getInstrumentData(
    _instrument: Address
  ): ethereum.CallResult<Vault__getInstrumentDataResultValue0Struct> {
    let result = super.tryCall(
      "getInstrumentData",
      "getInstrumentData(address):((bytes32,bool,bool,uint256,uint256,uint256,uint256,uint256,uint256,string,address,uint8,uint256,(uint256,uint256,uint256,uint256,uint256,uint256,uint256)))",
      [ethereum.Value.fromAddress(_instrument)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      changetype<Vault__getInstrumentDataResultValue0Struct>(value[0].toTuple())
    );
  }

  getInstrumentType(marketId: BigInt): BigInt {
    let result = super.call(
      "getInstrumentType",
      "getInstrumentType(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(marketId)]
    );

    return result[0].toBigInt();
  }

  try_getInstrumentType(marketId: BigInt): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getInstrumentType",
      "getInstrumentType(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(marketId)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  get_vault_params(): Vault__get_vault_paramsResultValue0Struct {
    let result = super.call(
      "get_vault_params",
      "get_vault_params():((uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256))",
      []
    );

    return changetype<Vault__get_vault_paramsResultValue0Struct>(
      result[0].toTuple()
    );
  }

  try_get_vault_params(): ethereum.CallResult<
    Vault__get_vault_paramsResultValue0Struct
  > {
    let result = super.tryCall(
      "get_vault_params",
      "get_vault_params():((uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256))",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      changetype<Vault__get_vault_paramsResultValue0Struct>(value[0].toTuple())
    );
  }

  instrumentApprovalCondition(marketId: BigInt): boolean {
    let result = super.call(
      "instrumentApprovalCondition",
      "instrumentApprovalCondition(uint256):(bool)",
      [ethereum.Value.fromUnsignedBigInt(marketId)]
    );

    return result[0].toBoolean();
  }

  try_instrumentApprovalCondition(
    marketId: BigInt
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "instrumentApprovalCondition",
      "instrumentApprovalCondition(uint256):(bool)",
      [ethereum.Value.fromUnsignedBigInt(marketId)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  instrumentAssetOracle(
    marketId: BigInt,
    juniorSupply: BigInt,
    seniorSupply: BigInt
  ): BigInt {
    let result = super.call(
      "instrumentAssetOracle",
      "instrumentAssetOracle(uint256,uint256,uint256):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(marketId),
        ethereum.Value.fromUnsignedBigInt(juniorSupply),
        ethereum.Value.fromUnsignedBigInt(seniorSupply)
      ]
    );

    return result[0].toBigInt();
  }

  try_instrumentAssetOracle(
    marketId: BigInt,
    juniorSupply: BigInt,
    seniorSupply: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "instrumentAssetOracle",
      "instrumentAssetOracle(uint256,uint256,uint256):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(marketId),
        ethereum.Value.fromUnsignedBigInt(juniorSupply),
        ethereum.Value.fromUnsignedBigInt(seniorSupply)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  instrument_data(param0: Address): Vault__instrument_dataResult {
    let result = super.call(
      "instrument_data",
      "instrument_data(address):(bytes32,bool,bool,uint256,uint256,uint256,uint256,uint256,uint256,string,address,uint8,uint256,(uint256,uint256,uint256,uint256,uint256,uint256,uint256))",
      [ethereum.Value.fromAddress(param0)]
    );

    return new Vault__instrument_dataResult(
      result[0].toBytes(),
      result[1].toBoolean(),
      result[2].toBoolean(),
      result[3].toBigInt(),
      result[4].toBigInt(),
      result[5].toBigInt(),
      result[6].toBigInt(),
      result[7].toBigInt(),
      result[8].toBigInt(),
      result[9].toString(),
      result[10].toAddress(),
      result[11].toI32(),
      result[12].toBigInt(),
      changetype<Vault__instrument_dataResultPoolDataStruct>(
        result[13].toTuple()
      )
    );
  }

  try_instrument_data(
    param0: Address
  ): ethereum.CallResult<Vault__instrument_dataResult> {
    let result = super.tryCall(
      "instrument_data",
      "instrument_data(address):(bytes32,bool,bool,uint256,uint256,uint256,uint256,uint256,uint256,string,address,uint8,uint256,(uint256,uint256,uint256,uint256,uint256,uint256,uint256))",
      [ethereum.Value.fromAddress(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new Vault__instrument_dataResult(
        value[0].toBytes(),
        value[1].toBoolean(),
        value[2].toBoolean(),
        value[3].toBigInt(),
        value[4].toBigInt(),
        value[5].toBigInt(),
        value[6].toBigInt(),
        value[7].toBigInt(),
        value[8].toBigInt(),
        value[9].toString(),
        value[10].toAddress(),
        value[11].toI32(),
        value[12].toBigInt(),
        changetype<Vault__instrument_dataResultPoolDataStruct>(
          value[13].toTuple()
        )
      )
    );
  }

  isTrusted(instrument: Address): boolean {
    let result = super.call("isTrusted", "isTrusted(address):(bool)", [
      ethereum.Value.fromAddress(instrument)
    ]);

    return result[0].toBoolean();
  }

  try_isTrusted(instrument: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall("isTrusted", "isTrusted(address):(bool)", [
      ethereum.Value.fromAddress(instrument)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  maxDeposit(param0: Address): BigInt {
    let result = super.call("maxDeposit", "maxDeposit(address):(uint256)", [
      ethereum.Value.fromAddress(param0)
    ]);

    return result[0].toBigInt();
  }

  try_maxDeposit(param0: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall("maxDeposit", "maxDeposit(address):(uint256)", [
      ethereum.Value.fromAddress(param0)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  maxMint(param0: Address): BigInt {
    let result = super.call("maxMint", "maxMint(address):(uint256)", [
      ethereum.Value.fromAddress(param0)
    ]);

    return result[0].toBigInt();
  }

  try_maxMint(param0: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall("maxMint", "maxMint(address):(uint256)", [
      ethereum.Value.fromAddress(param0)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  maxRedeem(owner: Address): BigInt {
    let result = super.call("maxRedeem", "maxRedeem(address):(uint256)", [
      ethereum.Value.fromAddress(owner)
    ]);

    return result[0].toBigInt();
  }

  try_maxRedeem(owner: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall("maxRedeem", "maxRedeem(address):(uint256)", [
      ethereum.Value.fromAddress(owner)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  maxWithdraw(owner: Address): BigInt {
    let result = super.call("maxWithdraw", "maxWithdraw(address):(uint256)", [
      ethereum.Value.fromAddress(owner)
    ]);

    return result[0].toBigInt();
  }

  try_maxWithdraw(owner: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "maxWithdraw",
      "maxWithdraw(address):(uint256)",
      [ethereum.Value.fromAddress(owner)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  mint(shares: BigInt, receiver: Address): BigInt {
    let result = super.call("mint", "mint(uint256,address):(uint256)", [
      ethereum.Value.fromUnsignedBigInt(shares),
      ethereum.Value.fromAddress(receiver)
    ]);

    return result[0].toBigInt();
  }

  try_mint(shares: BigInt, receiver: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall("mint", "mint(uint256,address):(uint256)", [
      ethereum.Value.fromUnsignedBigInt(shares),
      ethereum.Value.fromAddress(receiver)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  name(): string {
    let result = super.call("name", "name():(string)", []);

    return result[0].toString();
  }

  try_name(): ethereum.CallResult<string> {
    let result = super.tryCall("name", "name():(string)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  nonces(param0: Address): BigInt {
    let result = super.call("nonces", "nonces(address):(uint256)", [
      ethereum.Value.fromAddress(param0)
    ]);

    return result[0].toBigInt();
  }

  try_nonces(param0: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall("nonces", "nonces(address):(uint256)", [
      ethereum.Value.fromAddress(param0)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  onlyVerified(): boolean {
    let result = super.call("onlyVerified", "onlyVerified():(bool)", []);

    return result[0].toBoolean();
  }

  try_onlyVerified(): ethereum.CallResult<boolean> {
    let result = super.tryCall("onlyVerified", "onlyVerified():(bool)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  owner(): Address {
    let result = super.call("owner", "owner():(address)", []);

    return result[0].toAddress();
  }

  try_owner(): ethereum.CallResult<Address> {
    let result = super.tryCall("owner", "owner():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  poolZCBValue(marketId: BigInt): Vault__poolZCBValueResult {
    let result = super.call(
      "poolZCBValue",
      "poolZCBValue(uint256):(uint256,uint256,uint256)",
      [ethereum.Value.fromUnsignedBigInt(marketId)]
    );

    return new Vault__poolZCBValueResult(
      result[0].toBigInt(),
      result[1].toBigInt(),
      result[2].toBigInt()
    );
  }

  try_poolZCBValue(
    marketId: BigInt
  ): ethereum.CallResult<Vault__poolZCBValueResult> {
    let result = super.tryCall(
      "poolZCBValue",
      "poolZCBValue(uint256):(uint256,uint256,uint256)",
      [ethereum.Value.fromUnsignedBigInt(marketId)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new Vault__poolZCBValueResult(
        value[0].toBigInt(),
        value[1].toBigInt(),
        value[2].toBigInt()
      )
    );
  }

  previewDeposit(assets: BigInt): BigInt {
    let result = super.call(
      "previewDeposit",
      "previewDeposit(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(assets)]
    );

    return result[0].toBigInt();
  }

  try_previewDeposit(assets: BigInt): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "previewDeposit",
      "previewDeposit(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(assets)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  previewMint(shares: BigInt): BigInt {
    let result = super.call("previewMint", "previewMint(uint256):(uint256)", [
      ethereum.Value.fromUnsignedBigInt(shares)
    ]);

    return result[0].toBigInt();
  }

  try_previewMint(shares: BigInt): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "previewMint",
      "previewMint(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(shares)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  previewRedeem(shares: BigInt): BigInt {
    let result = super.call(
      "previewRedeem",
      "previewRedeem(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(shares)]
    );

    return result[0].toBigInt();
  }

  try_previewRedeem(shares: BigInt): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "previewRedeem",
      "previewRedeem(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(shares)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  previewWithdraw(assets: BigInt): BigInt {
    let result = super.call(
      "previewWithdraw",
      "previewWithdraw(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(assets)]
    );

    return result[0].toBigInt();
  }

  try_previewWithdraw(assets: BigInt): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "previewWithdraw",
      "previewWithdraw(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(assets)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  r(): BigInt {
    let result = super.call("r", "r():(uint256)", []);

    return result[0].toBigInt();
  }

  try_r(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("r", "r():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  receiver_conditions(receiver: Address): boolean {
    let result = super.call(
      "receiver_conditions",
      "receiver_conditions(address):(bool)",
      [ethereum.Value.fromAddress(receiver)]
    );

    return result[0].toBoolean();
  }

  try_receiver_conditions(receiver: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "receiver_conditions",
      "receiver_conditions(address):(bool)",
      [ethereum.Value.fromAddress(receiver)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  redeem(shares: BigInt, receiver: Address, owner: Address): BigInt {
    let result = super.call(
      "redeem",
      "redeem(uint256,address,address):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(shares),
        ethereum.Value.fromAddress(receiver),
        ethereum.Value.fromAddress(owner)
      ]
    );

    return result[0].toBigInt();
  }

  try_redeem(
    shares: BigInt,
    receiver: Address,
    owner: Address
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "redeem",
      "redeem(uint256,address,address):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(shares),
        ethereum.Value.fromAddress(receiver),
        ethereum.Value.fromAddress(owner)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  resolveInstrument(marketId: BigInt): Vault__resolveInstrumentResult {
    let result = super.call(
      "resolveInstrument",
      "resolveInstrument(uint256):(bool,uint256,uint256,bool)",
      [ethereum.Value.fromUnsignedBigInt(marketId)]
    );

    return new Vault__resolveInstrumentResult(
      result[0].toBoolean(),
      result[1].toBigInt(),
      result[2].toBigInt(),
      result[3].toBoolean()
    );
  }

  try_resolveInstrument(
    marketId: BigInt
  ): ethereum.CallResult<Vault__resolveInstrumentResult> {
    let result = super.tryCall(
      "resolveInstrument",
      "resolveInstrument(uint256):(bool,uint256,uint256,bool)",
      [ethereum.Value.fromUnsignedBigInt(marketId)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new Vault__resolveInstrumentResult(
        value[0].toBoolean(),
        value[1].toBigInt(),
        value[2].toBigInt(),
        value[3].toBoolean()
      )
    );
  }

  symbol(): string {
    let result = super.call("symbol", "symbol():(string)", []);

    return result[0].toString();
  }

  try_symbol(): ethereum.CallResult<string> {
    let result = super.tryCall("symbol", "symbol():(string)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  totalAssets(): BigInt {
    let result = super.call("totalAssets", "totalAssets():(uint256)", []);

    return result[0].toBigInt();
  }

  try_totalAssets(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("totalAssets", "totalAssets():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  totalFloat(): BigInt {
    let result = super.call("totalFloat", "totalFloat():(uint256)", []);

    return result[0].toBigInt();
  }

  try_totalFloat(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("totalFloat", "totalFloat():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  totalSupply(): BigInt {
    let result = super.call("totalSupply", "totalSupply():(uint256)", []);

    return result[0].toBigInt();
  }

  try_totalSupply(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("totalSupply", "totalSupply():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  total_asset_limit(): BigInt {
    let result = super.call(
      "total_asset_limit",
      "total_asset_limit():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_total_asset_limit(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "total_asset_limit",
      "total_asset_limit():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  transfer(to: Address, amount: BigInt): boolean {
    let result = super.call("transfer", "transfer(address,uint256):(bool)", [
      ethereum.Value.fromAddress(to),
      ethereum.Value.fromUnsignedBigInt(amount)
    ]);

    return result[0].toBoolean();
  }

  try_transfer(to: Address, amount: BigInt): ethereum.CallResult<boolean> {
    let result = super.tryCall("transfer", "transfer(address,uint256):(bool)", [
      ethereum.Value.fromAddress(to),
      ethereum.Value.fromUnsignedBigInt(amount)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  transferFrom(from: Address, to: Address, amount: BigInt): boolean {
    let result = super.call(
      "transferFrom",
      "transferFrom(address,address,uint256):(bool)",
      [
        ethereum.Value.fromAddress(from),
        ethereum.Value.fromAddress(to),
        ethereum.Value.fromUnsignedBigInt(amount)
      ]
    );

    return result[0].toBoolean();
  }

  try_transferFrom(
    from: Address,
    to: Address,
    amount: BigInt
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "transferFrom",
      "transferFrom(address,address,uint256):(bool)",
      [
        ethereum.Value.fromAddress(from),
        ethereum.Value.fromAddress(to),
        ethereum.Value.fromUnsignedBigInt(amount)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  utilizationRate(): BigInt {
    let result = super.call(
      "utilizationRate",
      "utilizationRate():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_utilizationRate(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "utilizationRate",
      "utilizationRate():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  viewPrincipalAndYield(marketId: BigInt): Vault__viewPrincipalAndYieldResult {
    let result = super.call(
      "viewPrincipalAndYield",
      "viewPrincipalAndYield(uint256):(uint256,uint256)",
      [ethereum.Value.fromUnsignedBigInt(marketId)]
    );

    return new Vault__viewPrincipalAndYieldResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_viewPrincipalAndYield(
    marketId: BigInt
  ): ethereum.CallResult<Vault__viewPrincipalAndYieldResult> {
    let result = super.tryCall(
      "viewPrincipalAndYield",
      "viewPrincipalAndYield(uint256):(uint256,uint256)",
      [ethereum.Value.fromUnsignedBigInt(marketId)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new Vault__viewPrincipalAndYieldResult(
        value[0].toBigInt(),
        value[1].toBigInt()
      )
    );
  }

  withdraw(assets: BigInt, receiver: Address, owner: Address): BigInt {
    let result = super.call(
      "withdraw",
      "withdraw(uint256,address,address):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(assets),
        ethereum.Value.fromAddress(receiver),
        ethereum.Value.fromAddress(owner)
      ]
    );

    return result[0].toBigInt();
  }

  try_withdraw(
    assets: BigInt,
    receiver: Address,
    owner: Address
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "withdraw",
      "withdraw(uint256,address,address):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(assets),
        ethereum.Value.fromAddress(receiver),
        ethereum.Value.fromAddress(owner)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }

  get _UNDERLYING(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _controller(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _owner(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get _onlyVerified(): boolean {
    return this._call.inputValues[3].value.toBoolean();
  }

  get _r(): BigInt {
    return this._call.inputValues[4].value.toBigInt();
  }

  get _asset_limit(): BigInt {
    return this._call.inputValues[5].value.toBigInt();
  }

  get _total_asset_limit(): BigInt {
    return this._call.inputValues[6].value.toBigInt();
  }

  get _default_params(): ConstructorCall_default_paramsStruct {
    return changetype<ConstructorCall_default_paramsStruct>(
      this._call.inputValues[7].value.toTuple()
    );
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class ConstructorCall_default_paramsStruct extends ethereum.Tuple {
  get N(): BigInt {
    return this[0].toBigInt();
  }

  get sigma(): BigInt {
    return this[1].toBigInt();
  }

  get alpha(): BigInt {
    return this[2].toBigInt();
  }

  get omega(): BigInt {
    return this[3].toBigInt();
  }

  get delta(): BigInt {
    return this[4].toBigInt();
  }

  get r(): BigInt {
    return this[5].toBigInt();
  }

  get s(): BigInt {
    return this[6].toBigInt();
  }

  get steak(): BigInt {
    return this[7].toBigInt();
  }
}

export class AddLendingModuleCall extends ethereum.Call {
  get inputs(): AddLendingModuleCall__Inputs {
    return new AddLendingModuleCall__Inputs(this);
  }

  get outputs(): AddLendingModuleCall__Outputs {
    return new AddLendingModuleCall__Outputs(this);
  }
}

export class AddLendingModuleCall__Inputs {
  _call: AddLendingModuleCall;

  constructor(call: AddLendingModuleCall) {
    this._call = call;
  }

  get lv(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class AddLendingModuleCall__Outputs {
  _call: AddLendingModuleCall;

  constructor(call: AddLendingModuleCall) {
    this._call = call;
  }
}

export class AddProposalCall extends ethereum.Call {
  get inputs(): AddProposalCall__Inputs {
    return new AddProposalCall__Inputs(this);
  }

  get outputs(): AddProposalCall__Outputs {
    return new AddProposalCall__Outputs(this);
  }
}

export class AddProposalCall__Inputs {
  _call: AddProposalCall;

  constructor(call: AddProposalCall) {
    this._call = call;
  }

  get data(): AddProposalCallDataStruct {
    return changetype<AddProposalCallDataStruct>(
      this._call.inputValues[0].value.toTuple()
    );
  }
}

export class AddProposalCall__Outputs {
  _call: AddProposalCall;

  constructor(call: AddProposalCall) {
    this._call = call;
  }
}

export class AddProposalCallDataStruct extends ethereum.Tuple {
  get name(): Bytes {
    return this[0].toBytes();
  }

  get isPool(): boolean {
    return this[1].toBoolean();
  }

  get trusted(): boolean {
    return this[2].toBoolean();
  }

  get balance(): BigInt {
    return this[3].toBigInt();
  }

  get faceValue(): BigInt {
    return this[4].toBigInt();
  }

  get marketId(): BigInt {
    return this[5].toBigInt();
  }

  get principal(): BigInt {
    return this[6].toBigInt();
  }

  get expectedYield(): BigInt {
    return this[7].toBigInt();
  }

  get duration(): BigInt {
    return this[8].toBigInt();
  }

  get description(): string {
    return this[9].toString();
  }

  get instrument_address(): Address {
    return this[10].toAddress();
  }

  get instrument_type(): i32 {
    return this[11].toI32();
  }

  get maturityDate(): BigInt {
    return this[12].toBigInt();
  }

  get poolData(): AddProposalCallDataPoolDataStruct {
    return changetype<AddProposalCallDataPoolDataStruct>(this[13].toTuple());
  }
}

export class AddProposalCallDataPoolDataStruct extends ethereum.Tuple {
  get saleAmount(): BigInt {
    return this[0].toBigInt();
  }

  get initPrice(): BigInt {
    return this[1].toBigInt();
  }

  get promisedReturn(): BigInt {
    return this[2].toBigInt();
  }

  get inceptionTime(): BigInt {
    return this[3].toBigInt();
  }

  get inceptionPrice(): BigInt {
    return this[4].toBigInt();
  }

  get leverageFactor(): BigInt {
    return this[5].toBigInt();
  }

  get managementFee(): BigInt {
    return this[6].toBigInt();
  }
}

export class ApproveCall extends ethereum.Call {
  get inputs(): ApproveCall__Inputs {
    return new ApproveCall__Inputs(this);
  }

  get outputs(): ApproveCall__Outputs {
    return new ApproveCall__Outputs(this);
  }
}

export class ApproveCall__Inputs {
  _call: ApproveCall;

  constructor(call: ApproveCall) {
    this._call = call;
  }

  get spender(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class ApproveCall__Outputs {
  _call: ApproveCall;

  constructor(call: ApproveCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class BeforeResolveCall extends ethereum.Call {
  get inputs(): BeforeResolveCall__Inputs {
    return new BeforeResolveCall__Inputs(this);
  }

  get outputs(): BeforeResolveCall__Outputs {
    return new BeforeResolveCall__Outputs(this);
  }
}

export class BeforeResolveCall__Inputs {
  _call: BeforeResolveCall;

  constructor(call: BeforeResolveCall) {
    this._call = call;
  }

  get marketId(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class BeforeResolveCall__Outputs {
  _call: BeforeResolveCall;

  constructor(call: BeforeResolveCall) {
    this._call = call;
  }
}

export class BurnCall extends ethereum.Call {
  get inputs(): BurnCall__Inputs {
    return new BurnCall__Inputs(this);
  }

  get outputs(): BurnCall__Outputs {
    return new BurnCall__Outputs(this);
  }
}

export class BurnCall__Inputs {
  _call: BurnCall;

  constructor(call: BurnCall) {
    this._call = call;
  }

  get shares(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class BurnCall__Outputs {
  _call: BurnCall;

  constructor(call: BurnCall) {
    this._call = call;
  }
}

export class CloseInstrumentCall extends ethereum.Call {
  get inputs(): CloseInstrumentCall__Inputs {
    return new CloseInstrumentCall__Inputs(this);
  }

  get outputs(): CloseInstrumentCall__Outputs {
    return new CloseInstrumentCall__Outputs(this);
  }
}

export class CloseInstrumentCall__Inputs {
  _call: CloseInstrumentCall;

  constructor(call: CloseInstrumentCall) {
    this._call = call;
  }

  get marketId(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class CloseInstrumentCall__Outputs {
  _call: CloseInstrumentCall;

  constructor(call: CloseInstrumentCall) {
    this._call = call;
  }
}

export class DenyInstrumentCall extends ethereum.Call {
  get inputs(): DenyInstrumentCall__Inputs {
    return new DenyInstrumentCall__Inputs(this);
  }

  get outputs(): DenyInstrumentCall__Outputs {
    return new DenyInstrumentCall__Outputs(this);
  }
}

export class DenyInstrumentCall__Inputs {
  _call: DenyInstrumentCall;

  constructor(call: DenyInstrumentCall) {
    this._call = call;
  }

  get marketId(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class DenyInstrumentCall__Outputs {
  _call: DenyInstrumentCall;

  constructor(call: DenyInstrumentCall) {
    this._call = call;
  }
}

export class DepositCall extends ethereum.Call {
  get inputs(): DepositCall__Inputs {
    return new DepositCall__Inputs(this);
  }

  get outputs(): DepositCall__Outputs {
    return new DepositCall__Outputs(this);
  }
}

export class DepositCall__Inputs {
  _call: DepositCall;

  constructor(call: DepositCall) {
    this._call = call;
  }

  get assets(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get receiver(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class DepositCall__Outputs {
  _call: DepositCall;

  constructor(call: DepositCall) {
    this._call = call;
  }

  get shares(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class DepositIntoInstrumentCall extends ethereum.Call {
  get inputs(): DepositIntoInstrumentCall__Inputs {
    return new DepositIntoInstrumentCall__Inputs(this);
  }

  get outputs(): DepositIntoInstrumentCall__Outputs {
    return new DepositIntoInstrumentCall__Outputs(this);
  }
}

export class DepositIntoInstrumentCall__Inputs {
  _call: DepositIntoInstrumentCall;

  constructor(call: DepositIntoInstrumentCall) {
    this._call = call;
  }

  get marketId(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get underlyingAmount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get isPool(): boolean {
    return this._call.inputValues[2].value.toBoolean();
  }
}

export class DepositIntoInstrumentCall__Outputs {
  _call: DepositIntoInstrumentCall;

  constructor(call: DepositIntoInstrumentCall) {
    this._call = call;
  }
}

export class DistrustInstrumentCall extends ethereum.Call {
  get inputs(): DistrustInstrumentCall__Inputs {
    return new DistrustInstrumentCall__Inputs(this);
  }

  get outputs(): DistrustInstrumentCall__Outputs {
    return new DistrustInstrumentCall__Outputs(this);
  }
}

export class DistrustInstrumentCall__Inputs {
  _call: DistrustInstrumentCall;

  constructor(call: DistrustInstrumentCall) {
    this._call = call;
  }

  get instrument(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class DistrustInstrumentCall__Outputs {
  _call: DistrustInstrumentCall;

  constructor(call: DistrustInstrumentCall) {
    this._call = call;
  }
}

export class HarvestCall extends ethereum.Call {
  get inputs(): HarvestCall__Inputs {
    return new HarvestCall__Inputs(this);
  }

  get outputs(): HarvestCall__Outputs {
    return new HarvestCall__Outputs(this);
  }
}

export class HarvestCall__Inputs {
  _call: HarvestCall;

  constructor(call: HarvestCall) {
    this._call = call;
  }

  get instrument(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class HarvestCall__Outputs {
  _call: HarvestCall;

  constructor(call: HarvestCall) {
    this._call = call;
  }
}

export class MintCall extends ethereum.Call {
  get inputs(): MintCall__Inputs {
    return new MintCall__Inputs(this);
  }

  get outputs(): MintCall__Outputs {
    return new MintCall__Outputs(this);
  }
}

export class MintCall__Inputs {
  _call: MintCall;

  constructor(call: MintCall) {
    this._call = call;
  }

  get shares(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get receiver(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class MintCall__Outputs {
  _call: MintCall;

  constructor(call: MintCall) {
    this._call = call;
  }

  get assets(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class PermitCall extends ethereum.Call {
  get inputs(): PermitCall__Inputs {
    return new PermitCall__Inputs(this);
  }

  get outputs(): PermitCall__Outputs {
    return new PermitCall__Outputs(this);
  }
}

export class PermitCall__Inputs {
  _call: PermitCall;

  constructor(call: PermitCall) {
    this._call = call;
  }

  get owner(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get spender(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get value(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get deadline(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }

  get v(): i32 {
    return this._call.inputValues[4].value.toI32();
  }

  get r(): Bytes {
    return this._call.inputValues[5].value.toBytes();
  }

  get s(): Bytes {
    return this._call.inputValues[6].value.toBytes();
  }
}

export class PermitCall__Outputs {
  _call: PermitCall;

  constructor(call: PermitCall) {
    this._call = call;
  }
}

export class PingMaturityCall extends ethereum.Call {
  get inputs(): PingMaturityCall__Inputs {
    return new PingMaturityCall__Inputs(this);
  }

  get outputs(): PingMaturityCall__Outputs {
    return new PingMaturityCall__Outputs(this);
  }
}

export class PingMaturityCall__Inputs {
  _call: PingMaturityCall;

  constructor(call: PingMaturityCall) {
    this._call = call;
  }

  get instrument(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get premature(): boolean {
    return this._call.inputValues[1].value.toBoolean();
  }
}

export class PingMaturityCall__Outputs {
  _call: PingMaturityCall;

  constructor(call: PingMaturityCall) {
    this._call = call;
  }
}

export class PullFromLMCall extends ethereum.Call {
  get inputs(): PullFromLMCall__Inputs {
    return new PullFromLMCall__Inputs(this);
  }

  get outputs(): PullFromLMCall__Outputs {
    return new PullFromLMCall__Outputs(this);
  }
}

export class PullFromLMCall__Inputs {
  _call: PullFromLMCall;

  constructor(call: PullFromLMCall) {
    this._call = call;
  }

  get amount(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class PullFromLMCall__Outputs {
  _call: PullFromLMCall;

  constructor(call: PullFromLMCall) {
    this._call = call;
  }
}

export class PushToLMCall extends ethereum.Call {
  get inputs(): PushToLMCall__Inputs {
    return new PushToLMCall__Inputs(this);
  }

  get outputs(): PushToLMCall__Outputs {
    return new PushToLMCall__Outputs(this);
  }
}

export class PushToLMCall__Inputs {
  _call: PushToLMCall;

  constructor(call: PushToLMCall) {
    this._call = call;
  }

  get amount(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class PushToLMCall__Outputs {
  _call: PushToLMCall;

  constructor(call: PushToLMCall) {
    this._call = call;
  }
}

export class RedeemCall extends ethereum.Call {
  get inputs(): RedeemCall__Inputs {
    return new RedeemCall__Inputs(this);
  }

  get outputs(): RedeemCall__Outputs {
    return new RedeemCall__Outputs(this);
  }
}

export class RedeemCall__Inputs {
  _call: RedeemCall;

  constructor(call: RedeemCall) {
    this._call = call;
  }

  get shares(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get receiver(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get owner(): Address {
    return this._call.inputValues[2].value.toAddress();
  }
}

export class RedeemCall__Outputs {
  _call: RedeemCall;

  constructor(call: RedeemCall) {
    this._call = call;
  }

  get assets(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class RepayDebtCall extends ethereum.Call {
  get inputs(): RepayDebtCall__Inputs {
    return new RepayDebtCall__Inputs(this);
  }

  get outputs(): RepayDebtCall__Outputs {
    return new RepayDebtCall__Outputs(this);
  }
}

export class RepayDebtCall__Inputs {
  _call: RepayDebtCall;

  constructor(call: RepayDebtCall) {
    this._call = call;
  }

  get to(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class RepayDebtCall__Outputs {
  _call: RepayDebtCall;

  constructor(call: RepayDebtCall) {
    this._call = call;
  }
}

export class ResolveInstrumentCall extends ethereum.Call {
  get inputs(): ResolveInstrumentCall__Inputs {
    return new ResolveInstrumentCall__Inputs(this);
  }

  get outputs(): ResolveInstrumentCall__Outputs {
    return new ResolveInstrumentCall__Outputs(this);
  }
}

export class ResolveInstrumentCall__Inputs {
  _call: ResolveInstrumentCall;

  constructor(call: ResolveInstrumentCall) {
    this._call = call;
  }

  get marketId(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class ResolveInstrumentCall__Outputs {
  _call: ResolveInstrumentCall;

  constructor(call: ResolveInstrumentCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }

  get value1(): BigInt {
    return this._call.outputValues[1].value.toBigInt();
  }

  get value2(): BigInt {
    return this._call.outputValues[2].value.toBigInt();
  }

  get value3(): boolean {
    return this._call.outputValues[3].value.toBoolean();
  }
}

export class TransferCall extends ethereum.Call {
  get inputs(): TransferCall__Inputs {
    return new TransferCall__Inputs(this);
  }

  get outputs(): TransferCall__Outputs {
    return new TransferCall__Outputs(this);
  }
}

export class TransferCall__Inputs {
  _call: TransferCall;

  constructor(call: TransferCall) {
    this._call = call;
  }

  get to(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class TransferCall__Outputs {
  _call: TransferCall;

  constructor(call: TransferCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class TransferFromCall extends ethereum.Call {
  get inputs(): TransferFromCall__Inputs {
    return new TransferFromCall__Inputs(this);
  }

  get outputs(): TransferFromCall__Outputs {
    return new TransferFromCall__Outputs(this);
  }
}

export class TransferFromCall__Inputs {
  _call: TransferFromCall;

  constructor(call: TransferFromCall) {
    this._call = call;
  }

  get from(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get to(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class TransferFromCall__Outputs {
  _call: TransferFromCall;

  constructor(call: TransferFromCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class TrustInstrumentCall extends ethereum.Call {
  get inputs(): TrustInstrumentCall__Inputs {
    return new TrustInstrumentCall__Inputs(this);
  }

  get outputs(): TrustInstrumentCall__Outputs {
    return new TrustInstrumentCall__Outputs(this);
  }
}

export class TrustInstrumentCall__Inputs {
  _call: TrustInstrumentCall;

  constructor(call: TrustInstrumentCall) {
    this._call = call;
  }

  get marketId(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get data(): TrustInstrumentCallDataStruct {
    return changetype<TrustInstrumentCallDataStruct>(
      this._call.inputValues[1].value.toTuple()
    );
  }

  get isPool(): boolean {
    return this._call.inputValues[2].value.toBoolean();
  }
}

export class TrustInstrumentCall__Outputs {
  _call: TrustInstrumentCall;

  constructor(call: TrustInstrumentCall) {
    this._call = call;
  }
}

export class TrustInstrumentCallDataStruct extends ethereum.Tuple {
  get managers_stake(): BigInt {
    return this[0].toBigInt();
  }

  get approved_principal(): BigInt {
    return this[1].toBigInt();
  }

  get approved_yield(): BigInt {
    return this[2].toBigInt();
  }
}

export class Trusted_transferCall extends ethereum.Call {
  get inputs(): Trusted_transferCall__Inputs {
    return new Trusted_transferCall__Inputs(this);
  }

  get outputs(): Trusted_transferCall__Outputs {
    return new Trusted_transferCall__Outputs(this);
  }
}

export class Trusted_transferCall__Inputs {
  _call: Trusted_transferCall;

  constructor(call: Trusted_transferCall) {
    this._call = call;
  }

  get amount(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get to(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class Trusted_transferCall__Outputs {
  _call: Trusted_transferCall;

  constructor(call: Trusted_transferCall) {
    this._call = call;
  }
}

export class WithdrawCall extends ethereum.Call {
  get inputs(): WithdrawCall__Inputs {
    return new WithdrawCall__Inputs(this);
  }

  get outputs(): WithdrawCall__Outputs {
    return new WithdrawCall__Outputs(this);
  }
}

export class WithdrawCall__Inputs {
  _call: WithdrawCall;

  constructor(call: WithdrawCall) {
    this._call = call;
  }

  get assets(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get receiver(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get owner(): Address {
    return this._call.inputValues[2].value.toAddress();
  }
}

export class WithdrawCall__Outputs {
  _call: WithdrawCall;

  constructor(call: WithdrawCall) {
    this._call = call;
  }

  get shares(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class WithdrawFromPoolInstrumentCall extends ethereum.Call {
  get inputs(): WithdrawFromPoolInstrumentCall__Inputs {
    return new WithdrawFromPoolInstrumentCall__Inputs(this);
  }

  get outputs(): WithdrawFromPoolInstrumentCall__Outputs {
    return new WithdrawFromPoolInstrumentCall__Outputs(this);
  }
}

export class WithdrawFromPoolInstrumentCall__Inputs {
  _call: WithdrawFromPoolInstrumentCall;

  constructor(call: WithdrawFromPoolInstrumentCall) {
    this._call = call;
  }

  get marketId(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get instrumentPullAmount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get pushTo(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get underlyingAmount(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }
}

export class WithdrawFromPoolInstrumentCall__Outputs {
  _call: WithdrawFromPoolInstrumentCall;

  constructor(call: WithdrawFromPoolInstrumentCall) {
    this._call = call;
  }
}
