// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class SyntheticZCBPool__claimPartiallyFilledOrderResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }

  getBaseAmount(): BigInt {
    return this.value0;
  }

  getTradeAmount(): BigInt {
    return this.value1;
  }
}

export class SyntheticZCBPool__collectResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }

  getAmount0(): BigInt {
    return this.value0;
  }

  getAmount1(): BigInt {
    return this.value1;
  }
}

export class SyntheticZCBPool__makerCloseResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }

  getToEscrowAmount(): BigInt {
    return this.value0;
  }

  getCrossId(): BigInt {
    return this.value1;
  }
}

export class SyntheticZCBPool__makerOpenResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }

  getToEscrowAmount(): BigInt {
    return this.value0;
  }

  getCrossId(): BigInt {
    return this.value1;
  }
}

export class SyntheticZCBPool__makerPartiallyClaimResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }

  getBaseAmount(): BigInt {
    return this.value0;
  }

  getTradeAmount(): BigInt {
    return this.value1;
  }
}

export class SyntheticZCBPool__placeLimitOrderResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }

  getAmountToEscrow(): BigInt {
    return this.value0;
  }

  getNumCross(): BigInt {
    return this.value1;
  }
}

export class SyntheticZCBPool__positionsResult {
  value0: BigInt;
  value1: BigInt;
  value2: BigInt;
  value3: BigInt;
  value4: BigInt;
  value5: BigInt;
  value6: BigInt;
  value7: BigInt;
  value8: BigInt;

  constructor(
    value0: BigInt,
    value1: BigInt,
    value2: BigInt,
    value3: BigInt,
    value4: BigInt,
    value5: BigInt,
    value6: BigInt,
    value7: BigInt,
    value8: BigInt
  ) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
    this.value3 = value3;
    this.value4 = value4;
    this.value5 = value5;
    this.value6 = value6;
    this.value7 = value7;
    this.value8 = value8;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    map.set("value2", ethereum.Value.fromUnsignedBigInt(this.value2));
    map.set("value3", ethereum.Value.fromUnsignedBigInt(this.value3));
    map.set("value4", ethereum.Value.fromUnsignedBigInt(this.value4));
    map.set("value5", ethereum.Value.fromUnsignedBigInt(this.value5));
    map.set("value6", ethereum.Value.fromUnsignedBigInt(this.value6));
    map.set("value7", ethereum.Value.fromUnsignedBigInt(this.value7));
    map.set("value8", ethereum.Value.fromUnsignedBigInt(this.value8));
    return map;
  }

  getBidCrossId(): BigInt {
    return this.value0;
  }

  getAskCrossId(): BigInt {
    return this.value1;
  }

  getAskLiq(): BigInt {
    return this.value2;
  }

  getBidLiq(): BigInt {
    return this.value3;
  }

  getLiquidity(): BigInt {
    return this.value4;
  }

  getFeeGrowthInside0LastX128(): BigInt {
    return this.value5;
  }

  getFeeGrowthInside1LastX128(): BigInt {
    return this.value6;
  }

  getTokensOwed0(): BigInt {
    return this.value7;
  }

  getTokensOwed1(): BigInt {
    return this.value8;
  }
}

export class SyntheticZCBPool__provideResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }

  getAmount0(): BigInt {
    return this.value0;
  }

  getAmount1(): BigInt {
    return this.value1;
  }
}

export class SyntheticZCBPool__removeResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }

  getValue0(): BigInt {
    return this.value0;
  }

  getValue1(): BigInt {
    return this.value1;
  }
}

export class SyntheticZCBPool__slot0Result {
  value0: BigInt;
  value1: i32;
  value2: i32;
  value3: boolean;
  value4: boolean;
  value5: i32;

  constructor(
    value0: BigInt,
    value1: i32,
    value2: i32,
    value3: boolean,
    value4: boolean,
    value5: i32
  ) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
    this.value3 = value3;
    this.value4 = value4;
    this.value5 = value5;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set(
      "value1",
      ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(this.value1))
    );
    map.set(
      "value2",
      ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(this.value2))
    );
    map.set("value3", ethereum.Value.fromBoolean(this.value3));
    map.set("value4", ethereum.Value.fromBoolean(this.value4));
    map.set(
      "value5",
      ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(this.value5))
    );
    return map;
  }

  getCurPrice(): BigInt {
    return this.value0;
  }

  getPoint(): i32 {
    return this.value1;
  }

  getFeeProtocol(): i32 {
    return this.value2;
  }

  getUnlocked(): boolean {
    return this.value3;
  }

  getAmortized(): boolean {
    return this.value4;
  }

  getModifyLiqPoint(): i32 {
    return this.value5;
  }
}

export class SyntheticZCBPool__takerCloseResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }

  getPoolamountIn(): BigInt {
    return this.value0;
  }

  getPoolamountOut(): BigInt {
    return this.value1;
  }
}

export class SyntheticZCBPool__takerOpenResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }

  getPoolamountIn(): BigInt {
    return this.value0;
  }

  getPoolamountOut(): BigInt {
    return this.value1;
  }
}

export class SyntheticZCBPool__ticksResult {
  value0: BigInt;
  value1: BigInt;
  value2: BigInt;
  value3: BigInt;
  value4: BigInt;
  value5: BigInt;
  value6: BigInt;
  value7: boolean;
  value8: BigInt;
  value9: BigInt;
  value10: BigInt;
  value11: BigInt;

  constructor(
    value0: BigInt,
    value1: BigInt,
    value2: BigInt,
    value3: BigInt,
    value4: BigInt,
    value5: BigInt,
    value6: BigInt,
    value7: boolean,
    value8: BigInt,
    value9: BigInt,
    value10: BigInt,
    value11: BigInt
  ) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
    this.value3 = value3;
    this.value4 = value4;
    this.value5 = value5;
    this.value6 = value6;
    this.value7 = value7;
    this.value8 = value8;
    this.value9 = value9;
    this.value10 = value10;
    this.value11 = value11;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromSignedBigInt(this.value1));
    map.set("value2", ethereum.Value.fromUnsignedBigInt(this.value2));
    map.set("value3", ethereum.Value.fromUnsignedBigInt(this.value3));
    map.set("value4", ethereum.Value.fromSignedBigInt(this.value4));
    map.set("value5", ethereum.Value.fromUnsignedBigInt(this.value5));
    map.set("value6", ethereum.Value.fromUnsignedBigInt(this.value6));
    map.set("value7", ethereum.Value.fromBoolean(this.value7));
    map.set("value8", ethereum.Value.fromUnsignedBigInt(this.value8));
    map.set("value9", ethereum.Value.fromUnsignedBigInt(this.value9));
    map.set("value10", ethereum.Value.fromUnsignedBigInt(this.value10));
    map.set("value11", ethereum.Value.fromUnsignedBigInt(this.value11));
    return map;
  }

  getLiquidityGross(): BigInt {
    return this.value0;
  }

  getLiquidityNet(): BigInt {
    return this.value1;
  }

  getFeeGrowthOutsideBase(): BigInt {
    return this.value2;
  }

  getFeeGrowthOutsideTrade(): BigInt {
    return this.value3;
  }

  getTickCumulativeOutside(): BigInt {
    return this.value4;
  }

  getSecondsPerLiquidityOutsideX128(): BigInt {
    return this.value5;
  }

  getSecondsOutside(): BigInt {
    return this.value6;
  }

  getInitialized(): boolean {
    return this.value7;
  }

  getAskLiquidityGross(): BigInt {
    return this.value8;
  }

  getBidLiquidityGross(): BigInt {
    return this.value9;
  }

  getAskNumCross(): BigInt {
    return this.value10;
  }

  getBidNumCross(): BigInt {
    return this.value11;
  }
}

export class SyntheticZCBPool__tradeResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }

  getAmountIn(): BigInt {
    return this.value0;
  }

  getAmountOut(): BigInt {
    return this.value1;
  }
}

export class SyntheticZCBPool extends ethereum.SmartContract {
  static bind(address: Address): SyntheticZCBPool {
    return new SyntheticZCBPool("SyntheticZCBPool", address);
  }

  BaseToken(): Address {
    let result = super.call("BaseToken", "BaseToken():(address)", []);

    return result[0].toAddress();
  }

  try_BaseToken(): ethereum.CallResult<Address> {
    let result = super.tryCall("BaseToken", "BaseToken():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  PRECISION(): BigInt {
    let result = super.call("PRECISION", "PRECISION():(uint256)", []);

    return result[0].toBigInt();
  }

  try_PRECISION(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("PRECISION", "PRECISION():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  ROUNDLIMIT(): BigInt {
    let result = super.call("ROUNDLIMIT", "ROUNDLIMIT():(uint256)", []);

    return result[0].toBigInt();
  }

  try_ROUNDLIMIT(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("ROUNDLIMIT", "ROUNDLIMIT():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  TradeToken(): Address {
    let result = super.call("TradeToken", "TradeToken():(address)", []);

    return result[0].toAddress();
  }

  try_TradeToken(): ethereum.CallResult<Address> {
    let result = super.tryCall("TradeToken", "TradeToken():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  a_initial(): BigInt {
    let result = super.call("a_initial", "a_initial():(uint256)", []);

    return result[0].toBigInt();
  }

  try_a_initial(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("a_initial", "a_initial():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  addDelta(x: BigInt, y: BigInt): BigInt {
    let result = super.call("addDelta", "addDelta(uint128,int128):(uint128)", [
      ethereum.Value.fromUnsignedBigInt(x),
      ethereum.Value.fromSignedBigInt(y)
    ]);

    return result[0].toBigInt();
  }

  try_addDelta(x: BigInt, y: BigInt): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "addDelta",
      "addDelta(uint128,int128):(uint128)",
      [ethereum.Value.fromUnsignedBigInt(x), ethereum.Value.fromSignedBigInt(y)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  areaBetweenCurveAndMax(amount: BigInt): BigInt {
    let result = super.call(
      "areaBetweenCurveAndMax",
      "areaBetweenCurveAndMax(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(amount)]
    );

    return result[0].toBigInt();
  }

  try_areaBetweenCurveAndMax(amount: BigInt): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "areaBetweenCurveAndMax",
      "areaBetweenCurveAndMax(uint256):(uint256)",
      [ethereum.Value.fromUnsignedBigInt(amount)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  b(): BigInt {
    let result = super.call("b", "b():(uint256)", []);

    return result[0].toBigInt();
  }

  try_b(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("b", "b():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  b_initial(): BigInt {
    let result = super.call("b_initial", "b_initial():(uint256)", []);

    return result[0].toBigInt();
  }

  try_b_initial(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("b_initial", "b_initial():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  baseBal(): BigInt {
    let result = super.call("baseBal", "baseBal():(uint256)", []);

    return result[0].toBigInt();
  }

  try_baseBal(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("baseBal", "baseBal():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  baseGivenLiquidity(p2: BigInt, p1: BigInt, L: BigInt): BigInt {
    let result = super.call(
      "baseGivenLiquidity",
      "baseGivenLiquidity(uint256,uint256,uint256):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(p2),
        ethereum.Value.fromUnsignedBigInt(p1),
        ethereum.Value.fromUnsignedBigInt(L)
      ]
    );

    return result[0].toBigInt();
  }

  try_baseGivenLiquidity(
    p2: BigInt,
    p1: BigInt,
    L: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "baseGivenLiquidity",
      "baseGivenLiquidity(uint256,uint256,uint256):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(p2),
        ethereum.Value.fromUnsignedBigInt(p1),
        ethereum.Value.fromUnsignedBigInt(L)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  baseToken(): Address {
    let result = super.call("baseToken", "baseToken():(address)", []);

    return result[0].toAddress();
  }

  try_baseToken(): ethereum.CallResult<Address> {
    let result = super.tryCall("baseToken", "baseToken():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  cBal(): BigInt {
    let result = super.call("cBal", "cBal():(uint256)", []);

    return result[0].toBigInt();
  }

  try_cBal(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("cBal", "cBal():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  calculateInitCurveParamsPool(
    saleAmount: BigInt,
    initPrice: BigInt,
    endPrice: BigInt,
    sigma: BigInt
  ): BigInt {
    let result = super.call(
      "calculateInitCurveParamsPool",
      "calculateInitCurveParamsPool(uint256,uint256,uint256,uint256):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(saleAmount),
        ethereum.Value.fromUnsignedBigInt(initPrice),
        ethereum.Value.fromUnsignedBigInt(endPrice),
        ethereum.Value.fromUnsignedBigInt(sigma)
      ]
    );

    return result[0].toBigInt();
  }

  try_calculateInitCurveParamsPool(
    saleAmount: BigInt,
    initPrice: BigInt,
    endPrice: BigInt,
    sigma: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "calculateInitCurveParamsPool",
      "calculateInitCurveParamsPool(uint256,uint256,uint256,uint256):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(saleAmount),
        ethereum.Value.fromUnsignedBigInt(initPrice),
        ethereum.Value.fromUnsignedBigInt(endPrice),
        ethereum.Value.fromUnsignedBigInt(sigma)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  claimFilledOrder(recipient: Address, point: i32, isAsk: boolean): BigInt {
    let result = super.call(
      "claimFilledOrder",
      "claimFilledOrder(address,uint16,bool):(uint256)",
      [
        ethereum.Value.fromAddress(recipient),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(point)),
        ethereum.Value.fromBoolean(isAsk)
      ]
    );

    return result[0].toBigInt();
  }

  try_claimFilledOrder(
    recipient: Address,
    point: i32,
    isAsk: boolean
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "claimFilledOrder",
      "claimFilledOrder(address,uint16,bool):(uint256)",
      [
        ethereum.Value.fromAddress(recipient),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(point)),
        ethereum.Value.fromBoolean(isAsk)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  claimPartiallyFilledOrder(
    recipient: Address,
    point: i32,
    isAsk: boolean
  ): SyntheticZCBPool__claimPartiallyFilledOrderResult {
    let result = super.call(
      "claimPartiallyFilledOrder",
      "claimPartiallyFilledOrder(address,uint16,bool):(uint256,uint256)",
      [
        ethereum.Value.fromAddress(recipient),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(point)),
        ethereum.Value.fromBoolean(isAsk)
      ]
    );

    return new SyntheticZCBPool__claimPartiallyFilledOrderResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_claimPartiallyFilledOrder(
    recipient: Address,
    point: i32,
    isAsk: boolean
  ): ethereum.CallResult<SyntheticZCBPool__claimPartiallyFilledOrderResult> {
    let result = super.tryCall(
      "claimPartiallyFilledOrder",
      "claimPartiallyFilledOrder(address,uint16,bool):(uint256,uint256)",
      [
        ethereum.Value.fromAddress(recipient),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(point)),
        ethereum.Value.fromBoolean(isAsk)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new SyntheticZCBPool__claimPartiallyFilledOrderResult(
        value[0].toBigInt(),
        value[1].toBigInt()
      )
    );
  }

  collect(
    recipient: Address,
    tickLower: i32,
    tickUpper: i32,
    amount0Requested: BigInt,
    amount1Requested: BigInt
  ): SyntheticZCBPool__collectResult {
    let result = super.call(
      "collect",
      "collect(address,uint16,uint16,uint128,uint128):(uint256,uint256)",
      [
        ethereum.Value.fromAddress(recipient),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(tickLower)),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(tickUpper)),
        ethereum.Value.fromUnsignedBigInt(amount0Requested),
        ethereum.Value.fromUnsignedBigInt(amount1Requested)
      ]
    );

    return new SyntheticZCBPool__collectResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_collect(
    recipient: Address,
    tickLower: i32,
    tickUpper: i32,
    amount0Requested: BigInt,
    amount1Requested: BigInt
  ): ethereum.CallResult<SyntheticZCBPool__collectResult> {
    let result = super.tryCall(
      "collect",
      "collect(address,uint16,uint16,uint128,uint128):(uint256,uint256)",
      [
        ethereum.Value.fromAddress(recipient),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(tickLower)),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(tickUpper)),
        ethereum.Value.fromUnsignedBigInt(amount0Requested),
        ethereum.Value.fromUnsignedBigInt(amount1Requested)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new SyntheticZCBPool__collectResult(
        value[0].toBigInt(),
        value[1].toBigInt()
      )
    );
  }

  controller(): Address {
    let result = super.call("controller", "controller():(address)", []);

    return result[0].toAddress();
  }

  try_controller(): ethereum.CallResult<Address> {
    let result = super.tryCall("controller", "controller():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  discount_cap(): BigInt {
    let result = super.call("discount_cap", "discount_cap():(uint256)", []);

    return result[0].toBigInt();
  }

  try_discount_cap(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("discount_cap", "discount_cap():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  discountedReserves(): BigInt {
    let result = super.call(
      "discountedReserves",
      "discountedReserves():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_discountedReserves(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "discountedReserves",
      "discountedReserves():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  entry(): Address {
    let result = super.call("entry", "entry():(address)", []);

    return result[0].toAddress();
  }

  try_entry(): ethereum.CallResult<Address> {
    let result = super.tryCall("entry", "entry():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  factory(): Address {
    let result = super.call("factory", "factory():(address)", []);

    return result[0].toAddress();
  }

  try_factory(): ethereum.CallResult<Address> {
    let result = super.tryCall("factory", "factory():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  fee(): i32 {
    let result = super.call("fee", "fee():(uint24)", []);

    return result[0].toI32();
  }

  try_fee(): ethereum.CallResult<i32> {
    let result = super.tryCall("fee", "fee():(uint24)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  feeGrowthGlobalBase(): BigInt {
    let result = super.call(
      "feeGrowthGlobalBase",
      "feeGrowthGlobalBase():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_feeGrowthGlobalBase(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "feeGrowthGlobalBase",
      "feeGrowthGlobalBase():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  feeGrowthGlobalTrade(): BigInt {
    let result = super.call(
      "feeGrowthGlobalTrade",
      "feeGrowthGlobalTrade():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_feeGrowthGlobalTrade(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "feeGrowthGlobalTrade",
      "feeGrowthGlobalTrade():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getCurPrice(): BigInt {
    let result = super.call("getCurPrice", "getCurPrice():(uint256)", []);

    return result[0].toBigInt();
  }

  try_getCurPrice(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("getCurPrice", "getCurPrice():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getLiq(to: Address, point: i32, isAsk: boolean): BigInt {
    let result = super.call("getLiq", "getLiq(address,uint16,bool):(uint128)", [
      ethereum.Value.fromAddress(to),
      ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(point)),
      ethereum.Value.fromBoolean(isAsk)
    ]);

    return result[0].toBigInt();
  }

  try_getLiq(
    to: Address,
    point: i32,
    isAsk: boolean
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getLiq",
      "getLiq(address,uint16,bool):(uint128)",
      [
        ethereum.Value.fromAddress(to),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(point)),
        ethereum.Value.fromBoolean(isAsk)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getNextPriceLimit(point: i32, pDelta: BigInt, moveUp: boolean): BigInt {
    let result = super.call(
      "getNextPriceLimit",
      "getNextPriceLimit(uint16,uint256,bool):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(point)),
        ethereum.Value.fromUnsignedBigInt(pDelta),
        ethereum.Value.fromBoolean(moveUp)
      ]
    );

    return result[0].toBigInt();
  }

  try_getNextPriceLimit(
    point: i32,
    pDelta: BigInt,
    moveUp: boolean
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getNextPriceLimit",
      "getNextPriceLimit(uint16,uint256,bool):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(point)),
        ethereum.Value.fromUnsignedBigInt(pDelta),
        ethereum.Value.fromBoolean(moveUp)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getNumCross(point: i32, moveUp: boolean): BigInt {
    let result = super.call(
      "getNumCross",
      "getNumCross(uint16,bool):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(point)),
        ethereum.Value.fromBoolean(moveUp)
      ]
    );

    return result[0].toBigInt();
  }

  try_getNumCross(point: i32, moveUp: boolean): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getNumCross",
      "getNumCross(uint16,bool):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(point)),
        ethereum.Value.fromBoolean(moveUp)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getOneTimeLiquidity(point: i32, moveUp: boolean): BigInt {
    let result = super.call(
      "getOneTimeLiquidity",
      "getOneTimeLiquidity(uint16,bool):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(point)),
        ethereum.Value.fromBoolean(moveUp)
      ]
    );

    return result[0].toBigInt();
  }

  try_getOneTimeLiquidity(
    point: i32,
    moveUp: boolean
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getOneTimeLiquidity",
      "getOneTimeLiquidity(uint16,bool):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(point)),
        ethereum.Value.fromBoolean(moveUp)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  liquidity(): BigInt {
    let result = super.call("liquidity", "liquidity():(uint128)", []);

    return result[0].toBigInt();
  }

  try_liquidity(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("liquidity", "liquidity():(uint128)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  liquidityGivenBase(p2: BigInt, p1: BigInt, B: BigInt): BigInt {
    let result = super.call(
      "liquidityGivenBase",
      "liquidityGivenBase(uint256,uint256,uint256):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(p2),
        ethereum.Value.fromUnsignedBigInt(p1),
        ethereum.Value.fromUnsignedBigInt(B)
      ]
    );

    return result[0].toBigInt();
  }

  try_liquidityGivenBase(
    p2: BigInt,
    p1: BigInt,
    B: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "liquidityGivenBase",
      "liquidityGivenBase(uint256,uint256,uint256):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(p2),
        ethereum.Value.fromUnsignedBigInt(p1),
        ethereum.Value.fromUnsignedBigInt(B)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  liquidityGivenTrade(p2: BigInt, p1: BigInt, T: BigInt): BigInt {
    let result = super.call(
      "liquidityGivenTrade",
      "liquidityGivenTrade(uint256,uint256,uint256):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(p2),
        ethereum.Value.fromUnsignedBigInt(p1),
        ethereum.Value.fromUnsignedBigInt(T)
      ]
    );

    return result[0].toBigInt();
  }

  try_liquidityGivenTrade(
    p2: BigInt,
    p1: BigInt,
    T: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "liquidityGivenTrade",
      "liquidityGivenTrade(uint256,uint256,uint256):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(p2),
        ethereum.Value.fromUnsignedBigInt(p1),
        ethereum.Value.fromUnsignedBigInt(T)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  makerClaimClose(point: i32, isLong: boolean, recipient: Address): BigInt {
    let result = super.call(
      "makerClaimClose",
      "makerClaimClose(uint16,bool,address):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(point)),
        ethereum.Value.fromBoolean(isLong),
        ethereum.Value.fromAddress(recipient)
      ]
    );

    return result[0].toBigInt();
  }

  try_makerClaimClose(
    point: i32,
    isLong: boolean,
    recipient: Address
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "makerClaimClose",
      "makerClaimClose(uint16,bool,address):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(point)),
        ethereum.Value.fromBoolean(isLong),
        ethereum.Value.fromAddress(recipient)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  makerClaimOpen(point: i32, isLong: boolean, recipient: Address): BigInt {
    let result = super.call(
      "makerClaimOpen",
      "makerClaimOpen(uint16,bool,address):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(point)),
        ethereum.Value.fromBoolean(isLong),
        ethereum.Value.fromAddress(recipient)
      ]
    );

    return result[0].toBigInt();
  }

  try_makerClaimOpen(
    point: i32,
    isLong: boolean,
    recipient: Address
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "makerClaimOpen",
      "makerClaimOpen(uint16,bool,address):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(point)),
        ethereum.Value.fromBoolean(isLong),
        ethereum.Value.fromAddress(recipient)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  makerClose(
    point: i32,
    amount: BigInt,
    isLong: boolean,
    recipient: Address
  ): SyntheticZCBPool__makerCloseResult {
    let result = super.call(
      "makerClose",
      "makerClose(uint16,uint256,bool,address):(uint256,uint128)",
      [
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(point)),
        ethereum.Value.fromUnsignedBigInt(amount),
        ethereum.Value.fromBoolean(isLong),
        ethereum.Value.fromAddress(recipient)
      ]
    );

    return new SyntheticZCBPool__makerCloseResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_makerClose(
    point: i32,
    amount: BigInt,
    isLong: boolean,
    recipient: Address
  ): ethereum.CallResult<SyntheticZCBPool__makerCloseResult> {
    let result = super.tryCall(
      "makerClose",
      "makerClose(uint16,uint256,bool,address):(uint256,uint128)",
      [
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(point)),
        ethereum.Value.fromUnsignedBigInt(amount),
        ethereum.Value.fromBoolean(isLong),
        ethereum.Value.fromAddress(recipient)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new SyntheticZCBPool__makerCloseResult(
        value[0].toBigInt(),
        value[1].toBigInt()
      )
    );
  }

  makerOpen(
    point: i32,
    amount: BigInt,
    isLong: boolean,
    recipient: Address
  ): SyntheticZCBPool__makerOpenResult {
    let result = super.call(
      "makerOpen",
      "makerOpen(uint16,uint256,bool,address):(uint256,uint128)",
      [
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(point)),
        ethereum.Value.fromUnsignedBigInt(amount),
        ethereum.Value.fromBoolean(isLong),
        ethereum.Value.fromAddress(recipient)
      ]
    );

    return new SyntheticZCBPool__makerOpenResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_makerOpen(
    point: i32,
    amount: BigInt,
    isLong: boolean,
    recipient: Address
  ): ethereum.CallResult<SyntheticZCBPool__makerOpenResult> {
    let result = super.tryCall(
      "makerOpen",
      "makerOpen(uint16,uint256,bool,address):(uint256,uint128)",
      [
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(point)),
        ethereum.Value.fromUnsignedBigInt(amount),
        ethereum.Value.fromBoolean(isLong),
        ethereum.Value.fromAddress(recipient)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new SyntheticZCBPool__makerOpenResult(
        value[0].toBigInt(),
        value[1].toBigInt()
      )
    );
  }

  makerPartiallyClaim(
    point: i32,
    isLong: boolean,
    open: boolean,
    recipient: Address
  ): SyntheticZCBPool__makerPartiallyClaimResult {
    let result = super.call(
      "makerPartiallyClaim",
      "makerPartiallyClaim(uint16,bool,bool,address):(uint256,uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(point)),
        ethereum.Value.fromBoolean(isLong),
        ethereum.Value.fromBoolean(open),
        ethereum.Value.fromAddress(recipient)
      ]
    );

    return new SyntheticZCBPool__makerPartiallyClaimResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_makerPartiallyClaim(
    point: i32,
    isLong: boolean,
    open: boolean,
    recipient: Address
  ): ethereum.CallResult<SyntheticZCBPool__makerPartiallyClaimResult> {
    let result = super.tryCall(
      "makerPartiallyClaim",
      "makerPartiallyClaim(uint16,bool,bool,address):(uint256,uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(point)),
        ethereum.Value.fromBoolean(isLong),
        ethereum.Value.fromBoolean(open),
        ethereum.Value.fromAddress(recipient)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new SyntheticZCBPool__makerPartiallyClaimResult(
        value[0].toBigInt(),
        value[1].toBigInt()
      )
    );
  }

  maxPrice(): BigInt {
    let result = super.call("maxPrice", "maxPrice():(uint256)", []);

    return result[0].toBigInt();
  }

  try_maxPrice(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("maxPrice", "maxPrice():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  owner(): Address {
    let result = super.call("owner", "owner():(address)", []);

    return result[0].toAddress();
  }

  try_owner(): ethereum.CallResult<Address> {
    let result = super.tryCall("owner", "owner():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  placeLimitOrder(
    recipient: Address,
    point: i32,
    amount: BigInt,
    isAsk: boolean
  ): SyntheticZCBPool__placeLimitOrderResult {
    let result = super.call(
      "placeLimitOrder",
      "placeLimitOrder(address,uint16,uint128,bool):(uint256,uint128)",
      [
        ethereum.Value.fromAddress(recipient),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(point)),
        ethereum.Value.fromUnsignedBigInt(amount),
        ethereum.Value.fromBoolean(isAsk)
      ]
    );

    return new SyntheticZCBPool__placeLimitOrderResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_placeLimitOrder(
    recipient: Address,
    point: i32,
    amount: BigInt,
    isAsk: boolean
  ): ethereum.CallResult<SyntheticZCBPool__placeLimitOrderResult> {
    let result = super.tryCall(
      "placeLimitOrder",
      "placeLimitOrder(address,uint16,uint128,bool):(uint256,uint128)",
      [
        ethereum.Value.fromAddress(recipient),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(point)),
        ethereum.Value.fromUnsignedBigInt(amount),
        ethereum.Value.fromBoolean(isAsk)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new SyntheticZCBPool__placeLimitOrderResult(
        value[0].toBigInt(),
        value[1].toBigInt()
      )
    );
  }

  pointToPrice(point: i32): BigInt {
    let result = super.call("pointToPrice", "pointToPrice(uint16):(uint160)", [
      ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(point))
    ]);

    return result[0].toBigInt();
  }

  try_pointToPrice(point: i32): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "pointToPrice",
      "pointToPrice(uint16):(uint160)",
      [ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(point))]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  positionIsFilled(recipient: Address, point: i32, isAsk: boolean): boolean {
    let result = super.call(
      "positionIsFilled",
      "positionIsFilled(address,uint16,bool):(bool)",
      [
        ethereum.Value.fromAddress(recipient),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(point)),
        ethereum.Value.fromBoolean(isAsk)
      ]
    );

    return result[0].toBoolean();
  }

  try_positionIsFilled(
    recipient: Address,
    point: i32,
    isAsk: boolean
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "positionIsFilled",
      "positionIsFilled(address,uint16,bool):(bool)",
      [
        ethereum.Value.fromAddress(recipient),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(point)),
        ethereum.Value.fromBoolean(isAsk)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  positions(param0: Bytes): SyntheticZCBPool__positionsResult {
    let result = super.call(
      "positions",
      "positions(bytes32):(uint128,uint128,uint128,uint128,uint128,uint256,uint256,uint256,uint256)",
      [ethereum.Value.fromFixedBytes(param0)]
    );

    return new SyntheticZCBPool__positionsResult(
      result[0].toBigInt(),
      result[1].toBigInt(),
      result[2].toBigInt(),
      result[3].toBigInt(),
      result[4].toBigInt(),
      result[5].toBigInt(),
      result[6].toBigInt(),
      result[7].toBigInt(),
      result[8].toBigInt()
    );
  }

  try_positions(
    param0: Bytes
  ): ethereum.CallResult<SyntheticZCBPool__positionsResult> {
    let result = super.tryCall(
      "positions",
      "positions(bytes32):(uint128,uint128,uint128,uint128,uint128,uint256,uint256,uint256,uint256)",
      [ethereum.Value.fromFixedBytes(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new SyntheticZCBPool__positionsResult(
        value[0].toBigInt(),
        value[1].toBigInt(),
        value[2].toBigInt(),
        value[3].toBigInt(),
        value[4].toBigInt(),
        value[5].toBigInt(),
        value[6].toBigInt(),
        value[7].toBigInt(),
        value[8].toBigInt()
      )
    );
  }

  precision(): BigInt {
    let result = super.call("precision", "precision():(uint256)", []);

    return result[0].toBigInt();
  }

  try_precision(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("precision", "precision():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  priceDelta(): BigInt {
    let result = super.call("priceDelta", "priceDelta():(uint256)", []);

    return result[0].toBigInt();
  }

  try_priceDelta(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("priceDelta", "priceDelta():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  priceToPoint(price: BigInt): i32 {
    let result = super.call("priceToPoint", "priceToPoint(uint256):(uint16)", [
      ethereum.Value.fromUnsignedBigInt(price)
    ]);

    return result[0].toI32();
  }

  try_priceToPoint(price: BigInt): ethereum.CallResult<i32> {
    let result = super.tryCall(
      "priceToPoint",
      "priceToPoint(uint256):(uint16)",
      [ethereum.Value.fromUnsignedBigInt(price)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  provide(
    recipient: Address,
    pointLower: i32,
    pointUpper: i32,
    amount: BigInt,
    data: Bytes
  ): SyntheticZCBPool__provideResult {
    let result = super.call(
      "provide",
      "provide(address,uint16,uint16,uint128,bytes):(uint256,uint256)",
      [
        ethereum.Value.fromAddress(recipient),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(pointLower)),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(pointUpper)),
        ethereum.Value.fromUnsignedBigInt(amount),
        ethereum.Value.fromBytes(data)
      ]
    );

    return new SyntheticZCBPool__provideResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_provide(
    recipient: Address,
    pointLower: i32,
    pointUpper: i32,
    amount: BigInt,
    data: Bytes
  ): ethereum.CallResult<SyntheticZCBPool__provideResult> {
    let result = super.tryCall(
      "provide",
      "provide(address,uint16,uint16,uint128,bytes):(uint256,uint256)",
      [
        ethereum.Value.fromAddress(recipient),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(pointLower)),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(pointUpper)),
        ethereum.Value.fromUnsignedBigInt(amount),
        ethereum.Value.fromBytes(data)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new SyntheticZCBPool__provideResult(
        value[0].toBigInt(),
        value[1].toBigInt()
      )
    );
  }

  reduceLimitOrder(
    recipient: Address,
    point: i32,
    amount: BigInt,
    isAsk: boolean
  ): BigInt {
    let result = super.call(
      "reduceLimitOrder",
      "reduceLimitOrder(address,uint16,uint128,bool):(uint256)",
      [
        ethereum.Value.fromAddress(recipient),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(point)),
        ethereum.Value.fromUnsignedBigInt(amount),
        ethereum.Value.fromBoolean(isAsk)
      ]
    );

    return result[0].toBigInt();
  }

  try_reduceLimitOrder(
    recipient: Address,
    point: i32,
    amount: BigInt,
    isAsk: boolean
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "reduceLimitOrder",
      "reduceLimitOrder(address,uint16,uint128,bool):(uint256)",
      [
        ethereum.Value.fromAddress(recipient),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(point)),
        ethereum.Value.fromUnsignedBigInt(amount),
        ethereum.Value.fromBoolean(isAsk)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  remove(
    recipient: Address,
    pointLower: i32,
    pointUpper: i32,
    amount: BigInt
  ): SyntheticZCBPool__removeResult {
    let result = super.call(
      "remove",
      "remove(address,uint16,uint16,uint128):(uint256,uint256)",
      [
        ethereum.Value.fromAddress(recipient),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(pointLower)),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(pointUpper)),
        ethereum.Value.fromUnsignedBigInt(amount)
      ]
    );

    return new SyntheticZCBPool__removeResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_remove(
    recipient: Address,
    pointLower: i32,
    pointUpper: i32,
    amount: BigInt
  ): ethereum.CallResult<SyntheticZCBPool__removeResult> {
    let result = super.tryCall(
      "remove",
      "remove(address,uint16,uint16,uint128):(uint256,uint256)",
      [
        ethereum.Value.fromAddress(recipient),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(pointLower)),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(pointUpper)),
        ethereum.Value.fromUnsignedBigInt(amount)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new SyntheticZCBPool__removeResult(
        value[0].toBigInt(),
        value[1].toBigInt()
      )
    );
  }

  s_tradeToken(): Address {
    let result = super.call("s_tradeToken", "s_tradeToken():(address)", []);

    return result[0].toAddress();
  }

  try_s_tradeToken(): ethereum.CallResult<Address> {
    let result = super.tryCall("s_tradeToken", "s_tradeToken():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  slot0(): SyntheticZCBPool__slot0Result {
    let result = super.call(
      "slot0",
      "slot0():(uint160,uint16,uint8,bool,bool,uint16)",
      []
    );

    return new SyntheticZCBPool__slot0Result(
      result[0].toBigInt(),
      result[1].toI32(),
      result[2].toI32(),
      result[3].toBoolean(),
      result[4].toBoolean(),
      result[5].toI32()
    );
  }

  try_slot0(): ethereum.CallResult<SyntheticZCBPool__slot0Result> {
    let result = super.tryCall(
      "slot0",
      "slot0():(uint160,uint16,uint8,bool,bool,uint16)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new SyntheticZCBPool__slot0Result(
        value[0].toBigInt(),
        value[1].toI32(),
        value[2].toI32(),
        value[3].toBoolean(),
        value[4].toBoolean(),
        value[5].toI32()
      )
    );
  }

  takerClose(
    isLong: boolean,
    amountIn: BigInt,
    priceLimit: BigInt,
    data: Bytes
  ): SyntheticZCBPool__takerCloseResult {
    let result = super.call(
      "takerClose",
      "takerClose(bool,int256,uint256,bytes):(uint256,uint256)",
      [
        ethereum.Value.fromBoolean(isLong),
        ethereum.Value.fromSignedBigInt(amountIn),
        ethereum.Value.fromUnsignedBigInt(priceLimit),
        ethereum.Value.fromBytes(data)
      ]
    );

    return new SyntheticZCBPool__takerCloseResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_takerClose(
    isLong: boolean,
    amountIn: BigInt,
    priceLimit: BigInt,
    data: Bytes
  ): ethereum.CallResult<SyntheticZCBPool__takerCloseResult> {
    let result = super.tryCall(
      "takerClose",
      "takerClose(bool,int256,uint256,bytes):(uint256,uint256)",
      [
        ethereum.Value.fromBoolean(isLong),
        ethereum.Value.fromSignedBigInt(amountIn),
        ethereum.Value.fromUnsignedBigInt(priceLimit),
        ethereum.Value.fromBytes(data)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new SyntheticZCBPool__takerCloseResult(
        value[0].toBigInt(),
        value[1].toBigInt()
      )
    );
  }

  takerOpen(
    isLong: boolean,
    amountIn: BigInt,
    priceLimit: BigInt,
    data: Bytes
  ): SyntheticZCBPool__takerOpenResult {
    let result = super.call(
      "takerOpen",
      "takerOpen(bool,int256,uint256,bytes):(uint256,uint256)",
      [
        ethereum.Value.fromBoolean(isLong),
        ethereum.Value.fromSignedBigInt(amountIn),
        ethereum.Value.fromUnsignedBigInt(priceLimit),
        ethereum.Value.fromBytes(data)
      ]
    );

    return new SyntheticZCBPool__takerOpenResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_takerOpen(
    isLong: boolean,
    amountIn: BigInt,
    priceLimit: BigInt,
    data: Bytes
  ): ethereum.CallResult<SyntheticZCBPool__takerOpenResult> {
    let result = super.tryCall(
      "takerOpen",
      "takerOpen(bool,int256,uint256,bytes):(uint256,uint256)",
      [
        ethereum.Value.fromBoolean(isLong),
        ethereum.Value.fromSignedBigInt(amountIn),
        ethereum.Value.fromUnsignedBigInt(priceLimit),
        ethereum.Value.fromBytes(data)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new SyntheticZCBPool__takerOpenResult(
        value[0].toBigInt(),
        value[1].toBigInt()
      )
    );
  }

  tickSpacing(): i32 {
    let result = super.call("tickSpacing", "tickSpacing():(int24)", []);

    return result[0].toI32();
  }

  try_tickSpacing(): ethereum.CallResult<i32> {
    let result = super.tryCall("tickSpacing", "tickSpacing():(int24)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  ticks(param0: i32): SyntheticZCBPool__ticksResult {
    let result = super.call(
      "ticks",
      "ticks(uint16):(uint128,int128,uint256,uint256,int56,uint160,uint32,bool,uint128,uint128,uint128,uint128)",
      [ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(param0))]
    );

    return new SyntheticZCBPool__ticksResult(
      result[0].toBigInt(),
      result[1].toBigInt(),
      result[2].toBigInt(),
      result[3].toBigInt(),
      result[4].toBigInt(),
      result[5].toBigInt(),
      result[6].toBigInt(),
      result[7].toBoolean(),
      result[8].toBigInt(),
      result[9].toBigInt(),
      result[10].toBigInt(),
      result[11].toBigInt()
    );
  }

  try_ticks(param0: i32): ethereum.CallResult<SyntheticZCBPool__ticksResult> {
    let result = super.tryCall(
      "ticks",
      "ticks(uint16):(uint128,int128,uint256,uint256,int56,uint160,uint32,bool,uint128,uint128,uint128,uint128)",
      [ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(param0))]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new SyntheticZCBPool__ticksResult(
        value[0].toBigInt(),
        value[1].toBigInt(),
        value[2].toBigInt(),
        value[3].toBigInt(),
        value[4].toBigInt(),
        value[5].toBigInt(),
        value[6].toBigInt(),
        value[7].toBoolean(),
        value[8].toBigInt(),
        value[9].toBigInt(),
        value[10].toBigInt(),
        value[11].toBigInt()
      )
    );
  }

  trade(
    recipient: Address,
    moveUp: boolean,
    amountSpecified: BigInt,
    priceLimit: BigInt,
    data: Bytes
  ): SyntheticZCBPool__tradeResult {
    let result = super.call(
      "trade",
      "trade(address,bool,int256,uint256,bytes):(uint256,uint256)",
      [
        ethereum.Value.fromAddress(recipient),
        ethereum.Value.fromBoolean(moveUp),
        ethereum.Value.fromSignedBigInt(amountSpecified),
        ethereum.Value.fromUnsignedBigInt(priceLimit),
        ethereum.Value.fromBytes(data)
      ]
    );

    return new SyntheticZCBPool__tradeResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_trade(
    recipient: Address,
    moveUp: boolean,
    amountSpecified: BigInt,
    priceLimit: BigInt,
    data: Bytes
  ): ethereum.CallResult<SyntheticZCBPool__tradeResult> {
    let result = super.tryCall(
      "trade",
      "trade(address,bool,int256,uint256,bytes):(uint256,uint256)",
      [
        ethereum.Value.fromAddress(recipient),
        ethereum.Value.fromBoolean(moveUp),
        ethereum.Value.fromSignedBigInt(amountSpecified),
        ethereum.Value.fromUnsignedBigInt(priceLimit),
        ethereum.Value.fromBytes(data)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new SyntheticZCBPool__tradeResult(
        value[0].toBigInt(),
        value[1].toBigInt()
      )
    );
  }

  tradeGivenLiquidity(p2: BigInt, p1: BigInt, L: BigInt): BigInt {
    let result = super.call(
      "tradeGivenLiquidity",
      "tradeGivenLiquidity(uint256,uint256,uint256):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(p2),
        ethereum.Value.fromUnsignedBigInt(p1),
        ethereum.Value.fromUnsignedBigInt(L)
      ]
    );

    return result[0].toBigInt();
  }

  try_tradeGivenLiquidity(
    p2: BigInt,
    p1: BigInt,
    L: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "tradeGivenLiquidity",
      "tradeGivenLiquidity(uint256,uint256,uint256):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(p2),
        ethereum.Value.fromUnsignedBigInt(p1),
        ethereum.Value.fromUnsignedBigInt(L)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  tradeToken(): Address {
    let result = super.call("tradeToken", "tradeToken():(address)", []);

    return result[0].toAddress();
  }

  try_tradeToken(): ethereum.CallResult<Address> {
    let result = super.tryCall("tradeToken", "tradeToken():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  xMax(curPrice: BigInt, b: BigInt, a: BigInt): BigInt {
    let result = super.call("xMax", "xMax(uint256,uint256,uint256):(uint256)", [
      ethereum.Value.fromUnsignedBigInt(curPrice),
      ethereum.Value.fromUnsignedBigInt(b),
      ethereum.Value.fromUnsignedBigInt(a)
    ]);

    return result[0].toBigInt();
  }

  try_xMax(
    curPrice: BigInt,
    b: BigInt,
    a: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "xMax",
      "xMax(uint256,uint256,uint256):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(curPrice),
        ethereum.Value.fromUnsignedBigInt(b),
        ethereum.Value.fromUnsignedBigInt(a)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  xMaxRoundUp(curPrice: BigInt, b: BigInt, a: BigInt): BigInt {
    let result = super.call(
      "xMaxRoundUp",
      "xMaxRoundUp(uint256,uint256,uint256):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(curPrice),
        ethereum.Value.fromUnsignedBigInt(b),
        ethereum.Value.fromUnsignedBigInt(a)
      ]
    );

    return result[0].toBigInt();
  }

  try_xMaxRoundUp(
    curPrice: BigInt,
    b: BigInt,
    a: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "xMaxRoundUp",
      "xMaxRoundUp(uint256,uint256,uint256):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(curPrice),
        ethereum.Value.fromUnsignedBigInt(b),
        ethereum.Value.fromUnsignedBigInt(a)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  yInt(curPrice: BigInt, moveUp: boolean): BigInt {
    let result = super.call("yInt", "yInt(uint256,bool):(uint256)", [
      ethereum.Value.fromUnsignedBigInt(curPrice),
      ethereum.Value.fromBoolean(moveUp)
    ]);

    return result[0].toBigInt();
  }

  try_yInt(curPrice: BigInt, moveUp: boolean): ethereum.CallResult<BigInt> {
    let result = super.tryCall("yInt", "yInt(uint256,bool):(uint256)", [
      ethereum.Value.fromUnsignedBigInt(curPrice),
      ethereum.Value.fromBoolean(moveUp)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }

  get base(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get trade(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get s_trade(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get _entry(): Address {
    return this._call.inputValues[3].value.toAddress();
  }

  get _controller(): Address {
    return this._call.inputValues[4].value.toAddress();
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class CalculateInitCurveParamsCall extends ethereum.Call {
  get inputs(): CalculateInitCurveParamsCall__Inputs {
    return new CalculateInitCurveParamsCall__Inputs(this);
  }

  get outputs(): CalculateInitCurveParamsCall__Outputs {
    return new CalculateInitCurveParamsCall__Outputs(this);
  }
}

export class CalculateInitCurveParamsCall__Inputs {
  _call: CalculateInitCurveParamsCall;

  constructor(call: CalculateInitCurveParamsCall) {
    this._call = call;
  }

  get P(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get I(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get sigma(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class CalculateInitCurveParamsCall__Outputs {
  _call: CalculateInitCurveParamsCall;

  constructor(call: CalculateInitCurveParamsCall) {
    this._call = call;
  }
}

export class CalculateInitCurveParamsPoolCall extends ethereum.Call {
  get inputs(): CalculateInitCurveParamsPoolCall__Inputs {
    return new CalculateInitCurveParamsPoolCall__Inputs(this);
  }

  get outputs(): CalculateInitCurveParamsPoolCall__Outputs {
    return new CalculateInitCurveParamsPoolCall__Outputs(this);
  }
}

export class CalculateInitCurveParamsPoolCall__Inputs {
  _call: CalculateInitCurveParamsPoolCall;

  constructor(call: CalculateInitCurveParamsPoolCall) {
    this._call = call;
  }

  get saleAmount(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get initPrice(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get endPrice(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get sigma(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }
}

export class CalculateInitCurveParamsPoolCall__Outputs {
  _call: CalculateInitCurveParamsPoolCall;

  constructor(call: CalculateInitCurveParamsPoolCall) {
    this._call = call;
  }

  get managementFee(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class ClaimFilledOrderCall extends ethereum.Call {
  get inputs(): ClaimFilledOrderCall__Inputs {
    return new ClaimFilledOrderCall__Inputs(this);
  }

  get outputs(): ClaimFilledOrderCall__Outputs {
    return new ClaimFilledOrderCall__Outputs(this);
  }
}

export class ClaimFilledOrderCall__Inputs {
  _call: ClaimFilledOrderCall;

  constructor(call: ClaimFilledOrderCall) {
    this._call = call;
  }

  get recipient(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get point(): i32 {
    return this._call.inputValues[1].value.toI32();
  }

  get isAsk(): boolean {
    return this._call.inputValues[2].value.toBoolean();
  }
}

export class ClaimFilledOrderCall__Outputs {
  _call: ClaimFilledOrderCall;

  constructor(call: ClaimFilledOrderCall) {
    this._call = call;
  }

  get claimedAmount(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class ClaimPartiallyFilledOrderCall extends ethereum.Call {
  get inputs(): ClaimPartiallyFilledOrderCall__Inputs {
    return new ClaimPartiallyFilledOrderCall__Inputs(this);
  }

  get outputs(): ClaimPartiallyFilledOrderCall__Outputs {
    return new ClaimPartiallyFilledOrderCall__Outputs(this);
  }
}

export class ClaimPartiallyFilledOrderCall__Inputs {
  _call: ClaimPartiallyFilledOrderCall;

  constructor(call: ClaimPartiallyFilledOrderCall) {
    this._call = call;
  }

  get recipient(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get point(): i32 {
    return this._call.inputValues[1].value.toI32();
  }

  get isAsk(): boolean {
    return this._call.inputValues[2].value.toBoolean();
  }
}

export class ClaimPartiallyFilledOrderCall__Outputs {
  _call: ClaimPartiallyFilledOrderCall;

  constructor(call: ClaimPartiallyFilledOrderCall) {
    this._call = call;
  }

  get baseAmount(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }

  get tradeAmount(): BigInt {
    return this._call.outputValues[1].value.toBigInt();
  }
}

export class CollectCall extends ethereum.Call {
  get inputs(): CollectCall__Inputs {
    return new CollectCall__Inputs(this);
  }

  get outputs(): CollectCall__Outputs {
    return new CollectCall__Outputs(this);
  }
}

export class CollectCall__Inputs {
  _call: CollectCall;

  constructor(call: CollectCall) {
    this._call = call;
  }

  get recipient(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get tickLower(): i32 {
    return this._call.inputValues[1].value.toI32();
  }

  get tickUpper(): i32 {
    return this._call.inputValues[2].value.toI32();
  }

  get amount0Requested(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }

  get amount1Requested(): BigInt {
    return this._call.inputValues[4].value.toBigInt();
  }
}

export class CollectCall__Outputs {
  _call: CollectCall;

  constructor(call: CollectCall) {
    this._call = call;
  }

  get amount0(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }

  get amount1(): BigInt {
    return this._call.outputValues[1].value.toBigInt();
  }
}

export class FlushCall extends ethereum.Call {
  get inputs(): FlushCall__Inputs {
    return new FlushCall__Inputs(this);
  }

  get outputs(): FlushCall__Outputs {
    return new FlushCall__Outputs(this);
  }
}

export class FlushCall__Inputs {
  _call: FlushCall;

  constructor(call: FlushCall) {
    this._call = call;
  }

  get flushTo(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class FlushCall__Outputs {
  _call: FlushCall;

  constructor(call: FlushCall) {
    this._call = call;
  }
}

export class LockCall extends ethereum.Call {
  get inputs(): LockCall__Inputs {
    return new LockCall__Inputs(this);
  }

  get outputs(): LockCall__Outputs {
    return new LockCall__Outputs(this);
  }
}

export class LockCall__Inputs {
  _call: LockCall;

  constructor(call: LockCall) {
    this._call = call;
  }
}

export class LockCall__Outputs {
  _call: LockCall;

  constructor(call: LockCall) {
    this._call = call;
  }
}

export class MakerClaimCloseCall extends ethereum.Call {
  get inputs(): MakerClaimCloseCall__Inputs {
    return new MakerClaimCloseCall__Inputs(this);
  }

  get outputs(): MakerClaimCloseCall__Outputs {
    return new MakerClaimCloseCall__Outputs(this);
  }
}

export class MakerClaimCloseCall__Inputs {
  _call: MakerClaimCloseCall;

  constructor(call: MakerClaimCloseCall) {
    this._call = call;
  }

  get point(): i32 {
    return this._call.inputValues[0].value.toI32();
  }

  get isLong(): boolean {
    return this._call.inputValues[1].value.toBoolean();
  }

  get recipient(): Address {
    return this._call.inputValues[2].value.toAddress();
  }
}

export class MakerClaimCloseCall__Outputs {
  _call: MakerClaimCloseCall;

  constructor(call: MakerClaimCloseCall) {
    this._call = call;
  }

  get claimedAmount(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class MakerClaimOpenCall extends ethereum.Call {
  get inputs(): MakerClaimOpenCall__Inputs {
    return new MakerClaimOpenCall__Inputs(this);
  }

  get outputs(): MakerClaimOpenCall__Outputs {
    return new MakerClaimOpenCall__Outputs(this);
  }
}

export class MakerClaimOpenCall__Inputs {
  _call: MakerClaimOpenCall;

  constructor(call: MakerClaimOpenCall) {
    this._call = call;
  }

  get point(): i32 {
    return this._call.inputValues[0].value.toI32();
  }

  get isLong(): boolean {
    return this._call.inputValues[1].value.toBoolean();
  }

  get recipient(): Address {
    return this._call.inputValues[2].value.toAddress();
  }
}

export class MakerClaimOpenCall__Outputs {
  _call: MakerClaimOpenCall;

  constructor(call: MakerClaimOpenCall) {
    this._call = call;
  }

  get claimedAmount(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class MakerCloseCall extends ethereum.Call {
  get inputs(): MakerCloseCall__Inputs {
    return new MakerCloseCall__Inputs(this);
  }

  get outputs(): MakerCloseCall__Outputs {
    return new MakerCloseCall__Outputs(this);
  }
}

export class MakerCloseCall__Inputs {
  _call: MakerCloseCall;

  constructor(call: MakerCloseCall) {
    this._call = call;
  }

  get point(): i32 {
    return this._call.inputValues[0].value.toI32();
  }

  get amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get isLong(): boolean {
    return this._call.inputValues[2].value.toBoolean();
  }

  get recipient(): Address {
    return this._call.inputValues[3].value.toAddress();
  }
}

export class MakerCloseCall__Outputs {
  _call: MakerCloseCall;

  constructor(call: MakerCloseCall) {
    this._call = call;
  }

  get toEscrowAmount(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }

  get crossId(): BigInt {
    return this._call.outputValues[1].value.toBigInt();
  }
}

export class MakerOpenCall extends ethereum.Call {
  get inputs(): MakerOpenCall__Inputs {
    return new MakerOpenCall__Inputs(this);
  }

  get outputs(): MakerOpenCall__Outputs {
    return new MakerOpenCall__Outputs(this);
  }
}

export class MakerOpenCall__Inputs {
  _call: MakerOpenCall;

  constructor(call: MakerOpenCall) {
    this._call = call;
  }

  get point(): i32 {
    return this._call.inputValues[0].value.toI32();
  }

  get amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get isLong(): boolean {
    return this._call.inputValues[2].value.toBoolean();
  }

  get recipient(): Address {
    return this._call.inputValues[3].value.toAddress();
  }
}

export class MakerOpenCall__Outputs {
  _call: MakerOpenCall;

  constructor(call: MakerOpenCall) {
    this._call = call;
  }

  get toEscrowAmount(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }

  get crossId(): BigInt {
    return this._call.outputValues[1].value.toBigInt();
  }
}

export class MakerPartiallyClaimCall extends ethereum.Call {
  get inputs(): MakerPartiallyClaimCall__Inputs {
    return new MakerPartiallyClaimCall__Inputs(this);
  }

  get outputs(): MakerPartiallyClaimCall__Outputs {
    return new MakerPartiallyClaimCall__Outputs(this);
  }
}

export class MakerPartiallyClaimCall__Inputs {
  _call: MakerPartiallyClaimCall;

  constructor(call: MakerPartiallyClaimCall) {
    this._call = call;
  }

  get point(): i32 {
    return this._call.inputValues[0].value.toI32();
  }

  get isLong(): boolean {
    return this._call.inputValues[1].value.toBoolean();
  }

  get open(): boolean {
    return this._call.inputValues[2].value.toBoolean();
  }

  get recipient(): Address {
    return this._call.inputValues[3].value.toAddress();
  }
}

export class MakerPartiallyClaimCall__Outputs {
  _call: MakerPartiallyClaimCall;

  constructor(call: MakerPartiallyClaimCall) {
    this._call = call;
  }

  get baseAmount(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }

  get tradeAmount(): BigInt {
    return this._call.outputValues[1].value.toBigInt();
  }
}

export class MakerReduceCloseCall extends ethereum.Call {
  get inputs(): MakerReduceCloseCall__Inputs {
    return new MakerReduceCloseCall__Inputs(this);
  }

  get outputs(): MakerReduceCloseCall__Outputs {
    return new MakerReduceCloseCall__Outputs(this);
  }
}

export class MakerReduceCloseCall__Inputs {
  _call: MakerReduceCloseCall;

  constructor(call: MakerReduceCloseCall) {
    this._call = call;
  }

  get point(): i32 {
    return this._call.inputValues[0].value.toI32();
  }

  get amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get isLong(): boolean {
    return this._call.inputValues[2].value.toBoolean();
  }

  get recipient(): Address {
    return this._call.inputValues[3].value.toAddress();
  }
}

export class MakerReduceCloseCall__Outputs {
  _call: MakerReduceCloseCall;

  constructor(call: MakerReduceCloseCall) {
    this._call = call;
  }
}

export class MakerReduceOpenCall extends ethereum.Call {
  get inputs(): MakerReduceOpenCall__Inputs {
    return new MakerReduceOpenCall__Inputs(this);
  }

  get outputs(): MakerReduceOpenCall__Outputs {
    return new MakerReduceOpenCall__Outputs(this);
  }
}

export class MakerReduceOpenCall__Inputs {
  _call: MakerReduceOpenCall;

  constructor(call: MakerReduceOpenCall) {
    this._call = call;
  }

  get point(): i32 {
    return this._call.inputValues[0].value.toI32();
  }

  get amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get isLong(): boolean {
    return this._call.inputValues[2].value.toBoolean();
  }

  get recipient(): Address {
    return this._call.inputValues[3].value.toAddress();
  }
}

export class MakerReduceOpenCall__Outputs {
  _call: MakerReduceOpenCall;

  constructor(call: MakerReduceOpenCall) {
    this._call = call;
  }
}

export class PlaceLimitOrderCall extends ethereum.Call {
  get inputs(): PlaceLimitOrderCall__Inputs {
    return new PlaceLimitOrderCall__Inputs(this);
  }

  get outputs(): PlaceLimitOrderCall__Outputs {
    return new PlaceLimitOrderCall__Outputs(this);
  }
}

export class PlaceLimitOrderCall__Inputs {
  _call: PlaceLimitOrderCall;

  constructor(call: PlaceLimitOrderCall) {
    this._call = call;
  }

  get recipient(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get point(): i32 {
    return this._call.inputValues[1].value.toI32();
  }

  get amount(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get isAsk(): boolean {
    return this._call.inputValues[3].value.toBoolean();
  }
}

export class PlaceLimitOrderCall__Outputs {
  _call: PlaceLimitOrderCall;

  constructor(call: PlaceLimitOrderCall) {
    this._call = call;
  }

  get amountToEscrow(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }

  get numCross(): BigInt {
    return this._call.outputValues[1].value.toBigInt();
  }
}

export class ProvideCall extends ethereum.Call {
  get inputs(): ProvideCall__Inputs {
    return new ProvideCall__Inputs(this);
  }

  get outputs(): ProvideCall__Outputs {
    return new ProvideCall__Outputs(this);
  }
}

export class ProvideCall__Inputs {
  _call: ProvideCall;

  constructor(call: ProvideCall) {
    this._call = call;
  }

  get recipient(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get pointLower(): i32 {
    return this._call.inputValues[1].value.toI32();
  }

  get pointUpper(): i32 {
    return this._call.inputValues[2].value.toI32();
  }

  get amount(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }

  get data(): Bytes {
    return this._call.inputValues[4].value.toBytes();
  }
}

export class ProvideCall__Outputs {
  _call: ProvideCall;

  constructor(call: ProvideCall) {
    this._call = call;
  }

  get amount0(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }

  get amount1(): BigInt {
    return this._call.outputValues[1].value.toBigInt();
  }
}

export class ProvideLiquidityCall extends ethereum.Call {
  get inputs(): ProvideLiquidityCall__Inputs {
    return new ProvideLiquidityCall__Inputs(this);
  }

  get outputs(): ProvideLiquidityCall__Outputs {
    return new ProvideLiquidityCall__Outputs(this);
  }
}

export class ProvideLiquidityCall__Inputs {
  _call: ProvideLiquidityCall;

  constructor(call: ProvideLiquidityCall) {
    this._call = call;
  }

  get pointLower(): i32 {
    return this._call.inputValues[0].value.toI32();
  }

  get pointUpper(): i32 {
    return this._call.inputValues[1].value.toI32();
  }

  get amount(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get data(): Bytes {
    return this._call.inputValues[3].value.toBytes();
  }
}

export class ProvideLiquidityCall__Outputs {
  _call: ProvideLiquidityCall;

  constructor(call: ProvideLiquidityCall) {
    this._call = call;
  }
}

export class ReduceLimitOrderCall extends ethereum.Call {
  get inputs(): ReduceLimitOrderCall__Inputs {
    return new ReduceLimitOrderCall__Inputs(this);
  }

  get outputs(): ReduceLimitOrderCall__Outputs {
    return new ReduceLimitOrderCall__Outputs(this);
  }
}

export class ReduceLimitOrderCall__Inputs {
  _call: ReduceLimitOrderCall;

  constructor(call: ReduceLimitOrderCall) {
    this._call = call;
  }

  get recipient(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get point(): i32 {
    return this._call.inputValues[1].value.toI32();
  }

  get amount(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get isAsk(): boolean {
    return this._call.inputValues[3].value.toBoolean();
  }
}

export class ReduceLimitOrderCall__Outputs {
  _call: ReduceLimitOrderCall;

  constructor(call: ReduceLimitOrderCall) {
    this._call = call;
  }

  get amountToReturn(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class RemoveCall extends ethereum.Call {
  get inputs(): RemoveCall__Inputs {
    return new RemoveCall__Inputs(this);
  }

  get outputs(): RemoveCall__Outputs {
    return new RemoveCall__Outputs(this);
  }
}

export class RemoveCall__Inputs {
  _call: RemoveCall;

  constructor(call: RemoveCall) {
    this._call = call;
  }

  get recipient(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get pointLower(): i32 {
    return this._call.inputValues[1].value.toI32();
  }

  get pointUpper(): i32 {
    return this._call.inputValues[2].value.toI32();
  }

  get amount(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }
}

export class RemoveCall__Outputs {
  _call: RemoveCall;

  constructor(call: RemoveCall) {
    this._call = call;
  }

  get value0(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }

  get value1(): BigInt {
    return this._call.outputValues[1].value.toBigInt();
  }
}

export class ResetLiqCall extends ethereum.Call {
  get inputs(): ResetLiqCall__Inputs {
    return new ResetLiqCall__Inputs(this);
  }

  get outputs(): ResetLiqCall__Outputs {
    return new ResetLiqCall__Outputs(this);
  }
}

export class ResetLiqCall__Inputs {
  _call: ResetLiqCall;

  constructor(call: ResetLiqCall) {
    this._call = call;
  }
}

export class ResetLiqCall__Outputs {
  _call: ResetLiqCall;

  constructor(call: ResetLiqCall) {
    this._call = call;
  }
}

export class SetEntryCall extends ethereum.Call {
  get inputs(): SetEntryCall__Inputs {
    return new SetEntryCall__Inputs(this);
  }

  get outputs(): SetEntryCall__Outputs {
    return new SetEntryCall__Outputs(this);
  }
}

export class SetEntryCall__Inputs {
  _call: SetEntryCall;

  constructor(call: SetEntryCall) {
    this._call = call;
  }

  get _entry(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class SetEntryCall__Outputs {
  _call: SetEntryCall;

  constructor(call: SetEntryCall) {
    this._call = call;
  }
}

export class TakerCloseCall extends ethereum.Call {
  get inputs(): TakerCloseCall__Inputs {
    return new TakerCloseCall__Inputs(this);
  }

  get outputs(): TakerCloseCall__Outputs {
    return new TakerCloseCall__Outputs(this);
  }
}

export class TakerCloseCall__Inputs {
  _call: TakerCloseCall;

  constructor(call: TakerCloseCall) {
    this._call = call;
  }

  get isLong(): boolean {
    return this._call.inputValues[0].value.toBoolean();
  }

  get amountIn(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get priceLimit(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get data(): Bytes {
    return this._call.inputValues[3].value.toBytes();
  }
}

export class TakerCloseCall__Outputs {
  _call: TakerCloseCall;

  constructor(call: TakerCloseCall) {
    this._call = call;
  }

  get poolamountIn(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }

  get poolamountOut(): BigInt {
    return this._call.outputValues[1].value.toBigInt();
  }
}

export class TakerOpenCall extends ethereum.Call {
  get inputs(): TakerOpenCall__Inputs {
    return new TakerOpenCall__Inputs(this);
  }

  get outputs(): TakerOpenCall__Outputs {
    return new TakerOpenCall__Outputs(this);
  }
}

export class TakerOpenCall__Inputs {
  _call: TakerOpenCall;

  constructor(call: TakerOpenCall) {
    this._call = call;
  }

  get isLong(): boolean {
    return this._call.inputValues[0].value.toBoolean();
  }

  get amountIn(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get priceLimit(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get data(): Bytes {
    return this._call.inputValues[3].value.toBytes();
  }
}

export class TakerOpenCall__Outputs {
  _call: TakerOpenCall;

  constructor(call: TakerOpenCall) {
    this._call = call;
  }

  get poolamountIn(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }

  get poolamountOut(): BigInt {
    return this._call.outputValues[1].value.toBigInt();
  }
}

export class TradeCall extends ethereum.Call {
  get inputs(): TradeCall__Inputs {
    return new TradeCall__Inputs(this);
  }

  get outputs(): TradeCall__Outputs {
    return new TradeCall__Outputs(this);
  }
}

export class TradeCall__Inputs {
  _call: TradeCall;

  constructor(call: TradeCall) {
    this._call = call;
  }

  get recipient(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get moveUp(): boolean {
    return this._call.inputValues[1].value.toBoolean();
  }

  get amountSpecified(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get priceLimit(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }

  get data(): Bytes {
    return this._call.inputValues[4].value.toBytes();
  }
}

export class TradeCall__Outputs {
  _call: TradeCall;

  constructor(call: TradeCall) {
    this._call = call;
  }

  get amountIn(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }

  get amountOut(): BigInt {
    return this._call.outputValues[1].value.toBigInt();
  }
}

export class TrustedBurnCall extends ethereum.Call {
  get inputs(): TrustedBurnCall__Inputs {
    return new TrustedBurnCall__Inputs(this);
  }

  get outputs(): TrustedBurnCall__Outputs {
    return new TrustedBurnCall__Outputs(this);
  }
}

export class TrustedBurnCall__Inputs {
  _call: TrustedBurnCall;

  constructor(call: TrustedBurnCall) {
    this._call = call;
  }

  get trader(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get long(): boolean {
    return this._call.inputValues[2].value.toBoolean();
  }
}

export class TrustedBurnCall__Outputs {
  _call: TrustedBurnCall;

  constructor(call: TrustedBurnCall) {
    this._call = call;
  }
}

export class TrustedDiscountedMintCall extends ethereum.Call {
  get inputs(): TrustedDiscountedMintCall__Inputs {
    return new TrustedDiscountedMintCall__Inputs(this);
  }

  get outputs(): TrustedDiscountedMintCall__Outputs {
    return new TrustedDiscountedMintCall__Outputs(this);
  }
}

export class TrustedDiscountedMintCall__Inputs {
  _call: TrustedDiscountedMintCall;

  constructor(call: TrustedDiscountedMintCall) {
    this._call = call;
  }

  get receiver(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class TrustedDiscountedMintCall__Outputs {
  _call: TrustedDiscountedMintCall;

  constructor(call: TrustedDiscountedMintCall) {
    this._call = call;
  }
}

export class WithdrawLiquidityCall extends ethereum.Call {
  get inputs(): WithdrawLiquidityCall__Inputs {
    return new WithdrawLiquidityCall__Inputs(this);
  }

  get outputs(): WithdrawLiquidityCall__Outputs {
    return new WithdrawLiquidityCall__Outputs(this);
  }
}

export class WithdrawLiquidityCall__Inputs {
  _call: WithdrawLiquidityCall;

  constructor(call: WithdrawLiquidityCall) {
    this._call = call;
  }

  get pointLower(): i32 {
    return this._call.inputValues[0].value.toI32();
  }

  get pointUpper(): i32 {
    return this._call.inputValues[1].value.toI32();
  }

  get amount(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get data(): Bytes {
    return this._call.inputValues[3].value.toBytes();
  }
}

export class WithdrawLiquidityCall__Outputs {
  _call: WithdrawLiquidityCall;

  constructor(call: WithdrawLiquidityCall) {
    this._call = call;
  }
}
